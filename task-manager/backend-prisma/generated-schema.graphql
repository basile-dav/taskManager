# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

enum ActionGroup {
  CREATE
  DELETE
  EDIT
}

enum ActionName {
  COMMENT_CREATE
  COMMENT_REPLY
  TASK_ASSIGN
  TASK_CREATE
  TASK_STATE_DONE
  TASK_STATE_INPROGRESS
  TASK_STATE_PENDING
}

enum ActionTargetType {
  COMMENT
  TASK
}

type Actions {
  _count: ActionsCount
  group: ActionGroup!
  id: ID!
  name: ActionName!
  notifications(cursor: NotificationsWhereUniqueInput, distinct: [NotificationsScalarFieldEnum!], orderBy: [NotificationsOrderByWithRelationInput!], skip: Int, take: Int, where: NotificationsWhereInput): [Notifications!]!
  target_id: String!
  target_type: ActionTargetType!
}

type ActionsCount {
  notifications: Int!
}

type ActionsCountAggregate {
  _all: Int!
  group: Int!
  id: Int!
  name: Int!
  target_id: Int!
  target_type: Int!
}

input ActionsCountOrderByAggregateInput {
  group: SortOrder
  id: SortOrder
  name: SortOrder
  target_id: SortOrder
  target_type: SortOrder
}

input ActionsCreateInput {
  group: ActionGroup!
  id: String
  name: ActionName!
  notifications: NotificationsCreateNestedManyWithoutActionsInput
  target_id: String
  target_type: ActionTargetType!
}

input ActionsCreateManyInput {
  group: ActionGroup!
  id: String
  name: ActionName!
  target_id: String
  target_type: ActionTargetType!
}

input ActionsCreateNestedOneWithoutNotificationsInput {
  connect: ActionsWhereUniqueInput
  connectOrCreate: ActionsCreateOrConnectWithoutNotificationsInput
  create: ActionsCreateWithoutNotificationsInput
}

input ActionsCreateOrConnectWithoutNotificationsInput {
  create: ActionsCreateWithoutNotificationsInput!
  where: ActionsWhereUniqueInput!
}

input ActionsCreateWithoutNotificationsInput {
  group: ActionGroup!
  id: String
  name: ActionName!
  target_id: String
  target_type: ActionTargetType!
}

type ActionsGroupBy {
  _count: ActionsCountAggregate
  _max: ActionsMaxAggregate
  _min: ActionsMinAggregate
  group: ActionGroup!
  id: String!
  name: ActionName!
  target_id: String!
  target_type: ActionTargetType!
}

type ActionsMaxAggregate {
  group: ActionGroup
  id: String
  name: ActionName
  target_id: String
  target_type: ActionTargetType
}

input ActionsMaxOrderByAggregateInput {
  group: SortOrder
  id: SortOrder
  name: SortOrder
  target_id: SortOrder
  target_type: SortOrder
}

type ActionsMinAggregate {
  group: ActionGroup
  id: String
  name: ActionName
  target_id: String
  target_type: ActionTargetType
}

input ActionsMinOrderByAggregateInput {
  group: SortOrder
  id: SortOrder
  name: SortOrder
  target_id: SortOrder
  target_type: SortOrder
}

input ActionsOrderByWithAggregationInput {
  _count: ActionsCountOrderByAggregateInput
  _max: ActionsMaxOrderByAggregateInput
  _min: ActionsMinOrderByAggregateInput
  group: SortOrder
  id: SortOrder
  name: SortOrder
  target_id: SortOrder
  target_type: SortOrder
}

input ActionsOrderByWithRelationInput {
  group: SortOrder
  id: SortOrder
  name: SortOrder
  notifications: NotificationsOrderByRelationAggregateInput
  target_id: SortOrder
  target_type: SortOrder
}

input ActionsRelationFilter {
  is: ActionsWhereInput
  isNot: ActionsWhereInput
}

enum ActionsScalarFieldEnum {
  group
  id
  name
  target_id
  target_type
}

input ActionsScalarWhereWithAggregatesInput {
  AND: [ActionsScalarWhereWithAggregatesInput!]
  NOT: [ActionsScalarWhereWithAggregatesInput!]
  OR: [ActionsScalarWhereWithAggregatesInput!]
  group: EnumActionGroupWithAggregatesFilter
  id: StringWithAggregatesFilter
  name: EnumActionNameWithAggregatesFilter
  target_id: StringWithAggregatesFilter
  target_type: EnumActionTargetTypeWithAggregatesFilter
}

input ActionsUpdateInput {
  group: EnumActionGroupFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: EnumActionNameFieldUpdateOperationsInput
  notifications: NotificationsUpdateManyWithoutActionsNestedInput
  target_id: StringFieldUpdateOperationsInput
  target_type: EnumActionTargetTypeFieldUpdateOperationsInput
}

input ActionsUpdateManyMutationInput {
  group: EnumActionGroupFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: EnumActionNameFieldUpdateOperationsInput
  target_id: StringFieldUpdateOperationsInput
  target_type: EnumActionTargetTypeFieldUpdateOperationsInput
}

input ActionsUpdateOneRequiredWithoutNotificationsNestedInput {
  connect: ActionsWhereUniqueInput
  connectOrCreate: ActionsCreateOrConnectWithoutNotificationsInput
  create: ActionsCreateWithoutNotificationsInput
  update: ActionsUpdateWithoutNotificationsInput
  upsert: ActionsUpsertWithoutNotificationsInput
}

input ActionsUpdateWithoutNotificationsInput {
  group: EnumActionGroupFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: EnumActionNameFieldUpdateOperationsInput
  target_id: StringFieldUpdateOperationsInput
  target_type: EnumActionTargetTypeFieldUpdateOperationsInput
}

input ActionsUpsertWithoutNotificationsInput {
  create: ActionsCreateWithoutNotificationsInput!
  update: ActionsUpdateWithoutNotificationsInput!
}

input ActionsWhereInput {
  AND: [ActionsWhereInput!]
  NOT: [ActionsWhereInput!]
  OR: [ActionsWhereInput!]
  group: EnumActionGroupFilter
  id: StringFilter
  name: EnumActionNameFilter
  notifications: NotificationsListRelationFilter
  target_id: StringFilter
  target_type: EnumActionTargetTypeFilter
}

input ActionsWhereUniqueInput {
  id: String
}

type AffectedRowsOutput {
  count: Int!
}

type AggregateActions {
  _count: ActionsCountAggregate
  _max: ActionsMaxAggregate
  _min: ActionsMinAggregate
}

type AggregateAssignees {
  _count: AssigneesCountAggregate
  _max: AssigneesMaxAggregate
  _min: AssigneesMinAggregate
}

type AggregateComments {
  _count: CommentsCountAggregate
  _max: CommentsMaxAggregate
  _min: CommentsMinAggregate
}

type AggregateNotifications {
  _count: NotificationsCountAggregate
  _max: NotificationsMaxAggregate
  _min: NotificationsMinAggregate
}

type AggregateTasks {
  _count: TasksCountAggregate
  _max: TasksMaxAggregate
  _min: TasksMinAggregate
}

type AggregateUsers {
  _count: UsersCountAggregate
  _max: UsersMaxAggregate
  _min: UsersMinAggregate
}

type Assignees {
  created_at: DateTime!
  id: ID!
  task_id: String!
  tasks: Tasks!
  user_id: String!
  users: Users!
}

type AssigneesCountAggregate {
  _all: Int!
  created_at: Int!
  id: Int!
  task_id: Int!
  user_id: Int!
}

input AssigneesCountOrderByAggregateInput {
  created_at: SortOrder
  id: SortOrder
  task_id: SortOrder
  user_id: SortOrder
}

input AssigneesCreateInput {
  created_at: DateTime!
  id: String
  tasks: TasksCreateNestedOneWithoutAssigneesInput
  users: UsersCreateNestedOneWithoutAssigneesInput
}

input AssigneesCreateManyInput {
  created_at: DateTime!
  id: String
  task_id: String
  user_id: String
}

input AssigneesCreateNestedOneWithoutTasksInput {
  connect: AssigneesWhereUniqueInput
  connectOrCreate: AssigneesCreateOrConnectWithoutTasksInput
  create: AssigneesCreateWithoutTasksInput
}

input AssigneesCreateNestedOneWithoutUsersInput {
  connect: AssigneesWhereUniqueInput
  connectOrCreate: AssigneesCreateOrConnectWithoutUsersInput
  create: AssigneesCreateWithoutUsersInput
}

input AssigneesCreateOrConnectWithoutTasksInput {
  create: AssigneesCreateWithoutTasksInput!
  where: AssigneesWhereUniqueInput!
}

input AssigneesCreateOrConnectWithoutUsersInput {
  create: AssigneesCreateWithoutUsersInput!
  where: AssigneesWhereUniqueInput!
}

input AssigneesCreateWithoutTasksInput {
  created_at: DateTime!
  id: String
  users: UsersCreateNestedOneWithoutAssigneesInput
}

input AssigneesCreateWithoutUsersInput {
  created_at: DateTime!
  id: String
  tasks: TasksCreateNestedOneWithoutAssigneesInput
}

type AssigneesGroupBy {
  _count: AssigneesCountAggregate
  _max: AssigneesMaxAggregate
  _min: AssigneesMinAggregate
  created_at: DateTime!
  id: String!
  task_id: String!
  user_id: String!
}

type AssigneesMaxAggregate {
  created_at: DateTime
  id: String
  task_id: String
  user_id: String
}

input AssigneesMaxOrderByAggregateInput {
  created_at: SortOrder
  id: SortOrder
  task_id: SortOrder
  user_id: SortOrder
}

type AssigneesMinAggregate {
  created_at: DateTime
  id: String
  task_id: String
  user_id: String
}

input AssigneesMinOrderByAggregateInput {
  created_at: SortOrder
  id: SortOrder
  task_id: SortOrder
  user_id: SortOrder
}

input AssigneesOrderByWithAggregationInput {
  _count: AssigneesCountOrderByAggregateInput
  _max: AssigneesMaxOrderByAggregateInput
  _min: AssigneesMinOrderByAggregateInput
  created_at: SortOrder
  id: SortOrder
  task_id: SortOrder
  user_id: SortOrder
}

input AssigneesOrderByWithRelationInput {
  created_at: SortOrder
  id: SortOrder
  task_id: SortOrder
  tasks: TasksOrderByWithRelationInput
  user_id: SortOrder
  users: UsersOrderByWithRelationInput
}

input AssigneesRelationFilter {
  is: AssigneesWhereInput
  isNot: AssigneesWhereInput
}

enum AssigneesScalarFieldEnum {
  created_at
  id
  task_id
  user_id
}

input AssigneesScalarWhereWithAggregatesInput {
  AND: [AssigneesScalarWhereWithAggregatesInput!]
  NOT: [AssigneesScalarWhereWithAggregatesInput!]
  OR: [AssigneesScalarWhereWithAggregatesInput!]
  created_at: DateTimeWithAggregatesFilter
  id: StringWithAggregatesFilter
  task_id: StringWithAggregatesFilter
  user_id: StringWithAggregatesFilter
}

input AssigneesUpdateInput {
  created_at: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  tasks: TasksUpdateOneRequiredWithoutAssigneesNestedInput
  users: UsersUpdateOneRequiredWithoutAssigneesNestedInput
}

input AssigneesUpdateManyMutationInput {
  created_at: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
}

input AssigneesUpdateOneWithoutTasksNestedInput {
  connect: AssigneesWhereUniqueInput
  connectOrCreate: AssigneesCreateOrConnectWithoutTasksInput
  create: AssigneesCreateWithoutTasksInput
  delete: Boolean
  disconnect: Boolean
  update: AssigneesUpdateWithoutTasksInput
  upsert: AssigneesUpsertWithoutTasksInput
}

input AssigneesUpdateOneWithoutUsersNestedInput {
  connect: AssigneesWhereUniqueInput
  connectOrCreate: AssigneesCreateOrConnectWithoutUsersInput
  create: AssigneesCreateWithoutUsersInput
  delete: Boolean
  disconnect: Boolean
  update: AssigneesUpdateWithoutUsersInput
  upsert: AssigneesUpsertWithoutUsersInput
}

input AssigneesUpdateWithoutTasksInput {
  created_at: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  users: UsersUpdateOneRequiredWithoutAssigneesNestedInput
}

input AssigneesUpdateWithoutUsersInput {
  created_at: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  tasks: TasksUpdateOneRequiredWithoutAssigneesNestedInput
}

input AssigneesUpsertWithoutTasksInput {
  create: AssigneesCreateWithoutTasksInput!
  update: AssigneesUpdateWithoutTasksInput!
}

input AssigneesUpsertWithoutUsersInput {
  create: AssigneesCreateWithoutUsersInput!
  update: AssigneesUpdateWithoutUsersInput!
}

input AssigneesWhereInput {
  AND: [AssigneesWhereInput!]
  NOT: [AssigneesWhereInput!]
  OR: [AssigneesWhereInput!]
  created_at: DateTimeFilter
  id: StringFilter
  task_id: StringFilter
  tasks: TasksRelationFilter
  user_id: StringFilter
  users: UsersRelationFilter
}

input AssigneesWhereUniqueInput {
  id: String
  task_id: String
  user_id: String
}

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input BoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

enum CommentTargetType {
  COMMENT_NEW
  COMMENT_REPLY
}

type Comments {
  content: String!
  created_at: DateTime!
  id: ID!
  owner_id: String!
  parent_id: String!
  target_id: String!
  target_type: CommentTargetType!
  tasks: Tasks!
  updated_at: DateTime!
  users: Users!
}

type CommentsCountAggregate {
  _all: Int!
  content: Int!
  created_at: Int!
  id: Int!
  owner_id: Int!
  parent_id: Int!
  target_id: Int!
  target_type: Int!
  updated_at: Int!
}

input CommentsCountOrderByAggregateInput {
  content: SortOrder
  created_at: SortOrder
  id: SortOrder
  owner_id: SortOrder
  parent_id: SortOrder
  target_id: SortOrder
  target_type: SortOrder
  updated_at: SortOrder
}

input CommentsCreateInput {
  content: String!
  created_at: DateTime!
  id: String
  parent_id: String
  target_type: CommentTargetType!
  tasks: TasksCreateNestedOneWithoutCommentsInput
  updated_at: DateTime!
  users: UsersCreateNestedOneWithoutCommentsInput
}

input CommentsCreateManyInput {
  content: String!
  created_at: DateTime!
  id: String
  owner_id: String
  parent_id: String
  target_id: String
  target_type: CommentTargetType!
  updated_at: DateTime!
}

input CommentsCreateManyTasksInput {
  content: String!
  created_at: DateTime!
  id: String
  owner_id: String
  parent_id: String
  target_type: CommentTargetType!
  updated_at: DateTime!
}

input CommentsCreateManyTasksInputEnvelope {
  data: [CommentsCreateManyTasksInput!]!
  skipDuplicates: Boolean
}

input CommentsCreateManyUsersInput {
  content: String!
  created_at: DateTime!
  id: String
  parent_id: String
  target_id: String
  target_type: CommentTargetType!
  updated_at: DateTime!
}

input CommentsCreateManyUsersInputEnvelope {
  data: [CommentsCreateManyUsersInput!]!
  skipDuplicates: Boolean
}

input CommentsCreateNestedManyWithoutTasksInput {
  connect: [CommentsWhereUniqueInput!]
  connectOrCreate: [CommentsCreateOrConnectWithoutTasksInput!]
  create: [CommentsCreateWithoutTasksInput!]
  createMany: CommentsCreateManyTasksInputEnvelope
}

input CommentsCreateNestedManyWithoutUsersInput {
  connect: [CommentsWhereUniqueInput!]
  connectOrCreate: [CommentsCreateOrConnectWithoutUsersInput!]
  create: [CommentsCreateWithoutUsersInput!]
  createMany: CommentsCreateManyUsersInputEnvelope
}

input CommentsCreateOrConnectWithoutTasksInput {
  create: CommentsCreateWithoutTasksInput!
  where: CommentsWhereUniqueInput!
}

input CommentsCreateOrConnectWithoutUsersInput {
  create: CommentsCreateWithoutUsersInput!
  where: CommentsWhereUniqueInput!
}

input CommentsCreateWithoutTasksInput {
  content: String!
  created_at: DateTime!
  id: String
  parent_id: String
  target_type: CommentTargetType!
  updated_at: DateTime!
  users: UsersCreateNestedOneWithoutCommentsInput
}

input CommentsCreateWithoutUsersInput {
  content: String!
  created_at: DateTime!
  id: String
  parent_id: String
  target_type: CommentTargetType!
  tasks: TasksCreateNestedOneWithoutCommentsInput
  updated_at: DateTime!
}

type CommentsGroupBy {
  _count: CommentsCountAggregate
  _max: CommentsMaxAggregate
  _min: CommentsMinAggregate
  content: String!
  created_at: DateTime!
  id: String!
  owner_id: String!
  parent_id: String!
  target_id: String!
  target_type: CommentTargetType!
  updated_at: DateTime!
}

input CommentsListRelationFilter {
  every: CommentsWhereInput
  none: CommentsWhereInput
  some: CommentsWhereInput
}

type CommentsMaxAggregate {
  content: String
  created_at: DateTime
  id: String
  owner_id: String
  parent_id: String
  target_id: String
  target_type: CommentTargetType
  updated_at: DateTime
}

input CommentsMaxOrderByAggregateInput {
  content: SortOrder
  created_at: SortOrder
  id: SortOrder
  owner_id: SortOrder
  parent_id: SortOrder
  target_id: SortOrder
  target_type: SortOrder
  updated_at: SortOrder
}

type CommentsMinAggregate {
  content: String
  created_at: DateTime
  id: String
  owner_id: String
  parent_id: String
  target_id: String
  target_type: CommentTargetType
  updated_at: DateTime
}

input CommentsMinOrderByAggregateInput {
  content: SortOrder
  created_at: SortOrder
  id: SortOrder
  owner_id: SortOrder
  parent_id: SortOrder
  target_id: SortOrder
  target_type: SortOrder
  updated_at: SortOrder
}

input CommentsOrderByRelationAggregateInput {
  _count: SortOrder
}

input CommentsOrderByWithAggregationInput {
  _count: CommentsCountOrderByAggregateInput
  _max: CommentsMaxOrderByAggregateInput
  _min: CommentsMinOrderByAggregateInput
  content: SortOrder
  created_at: SortOrder
  id: SortOrder
  owner_id: SortOrder
  parent_id: SortOrder
  target_id: SortOrder
  target_type: SortOrder
  updated_at: SortOrder
}

input CommentsOrderByWithRelationInput {
  content: SortOrder
  created_at: SortOrder
  id: SortOrder
  owner_id: SortOrder
  parent_id: SortOrder
  target_id: SortOrder
  target_type: SortOrder
  tasks: TasksOrderByWithRelationInput
  updated_at: SortOrder
  users: UsersOrderByWithRelationInput
}

enum CommentsScalarFieldEnum {
  content
  created_at
  id
  owner_id
  parent_id
  target_id
  target_type
  updated_at
}

input CommentsScalarWhereInput {
  AND: [CommentsScalarWhereInput!]
  NOT: [CommentsScalarWhereInput!]
  OR: [CommentsScalarWhereInput!]
  content: StringFilter
  created_at: DateTimeFilter
  id: StringFilter
  owner_id: StringFilter
  parent_id: StringFilter
  target_id: StringFilter
  target_type: EnumCommentTargetTypeFilter
  updated_at: DateTimeFilter
}

input CommentsScalarWhereWithAggregatesInput {
  AND: [CommentsScalarWhereWithAggregatesInput!]
  NOT: [CommentsScalarWhereWithAggregatesInput!]
  OR: [CommentsScalarWhereWithAggregatesInput!]
  content: StringWithAggregatesFilter
  created_at: DateTimeWithAggregatesFilter
  id: StringWithAggregatesFilter
  owner_id: StringWithAggregatesFilter
  parent_id: StringWithAggregatesFilter
  target_id: StringWithAggregatesFilter
  target_type: EnumCommentTargetTypeWithAggregatesFilter
  updated_at: DateTimeWithAggregatesFilter
}

input CommentsUpdateInput {
  content: StringFieldUpdateOperationsInput
  created_at: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  parent_id: StringFieldUpdateOperationsInput
  target_type: EnumCommentTargetTypeFieldUpdateOperationsInput
  tasks: TasksUpdateOneRequiredWithoutCommentsNestedInput
  updated_at: DateTimeFieldUpdateOperationsInput
  users: UsersUpdateOneRequiredWithoutCommentsNestedInput
}

input CommentsUpdateManyMutationInput {
  content: StringFieldUpdateOperationsInput
  created_at: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  parent_id: StringFieldUpdateOperationsInput
  target_type: EnumCommentTargetTypeFieldUpdateOperationsInput
  updated_at: DateTimeFieldUpdateOperationsInput
}

input CommentsUpdateManyWithWhereWithoutTasksInput {
  data: CommentsUpdateManyMutationInput!
  where: CommentsScalarWhereInput!
}

input CommentsUpdateManyWithWhereWithoutUsersInput {
  data: CommentsUpdateManyMutationInput!
  where: CommentsScalarWhereInput!
}

input CommentsUpdateManyWithoutTasksNestedInput {
  connect: [CommentsWhereUniqueInput!]
  connectOrCreate: [CommentsCreateOrConnectWithoutTasksInput!]
  create: [CommentsCreateWithoutTasksInput!]
  createMany: CommentsCreateManyTasksInputEnvelope
  delete: [CommentsWhereUniqueInput!]
  deleteMany: [CommentsScalarWhereInput!]
  disconnect: [CommentsWhereUniqueInput!]
  set: [CommentsWhereUniqueInput!]
  update: [CommentsUpdateWithWhereUniqueWithoutTasksInput!]
  updateMany: [CommentsUpdateManyWithWhereWithoutTasksInput!]
  upsert: [CommentsUpsertWithWhereUniqueWithoutTasksInput!]
}

input CommentsUpdateManyWithoutUsersNestedInput {
  connect: [CommentsWhereUniqueInput!]
  connectOrCreate: [CommentsCreateOrConnectWithoutUsersInput!]
  create: [CommentsCreateWithoutUsersInput!]
  createMany: CommentsCreateManyUsersInputEnvelope
  delete: [CommentsWhereUniqueInput!]
  deleteMany: [CommentsScalarWhereInput!]
  disconnect: [CommentsWhereUniqueInput!]
  set: [CommentsWhereUniqueInput!]
  update: [CommentsUpdateWithWhereUniqueWithoutUsersInput!]
  updateMany: [CommentsUpdateManyWithWhereWithoutUsersInput!]
  upsert: [CommentsUpsertWithWhereUniqueWithoutUsersInput!]
}

input CommentsUpdateWithWhereUniqueWithoutTasksInput {
  data: CommentsUpdateWithoutTasksInput!
  where: CommentsWhereUniqueInput!
}

input CommentsUpdateWithWhereUniqueWithoutUsersInput {
  data: CommentsUpdateWithoutUsersInput!
  where: CommentsWhereUniqueInput!
}

input CommentsUpdateWithoutTasksInput {
  content: StringFieldUpdateOperationsInput
  created_at: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  parent_id: StringFieldUpdateOperationsInput
  target_type: EnumCommentTargetTypeFieldUpdateOperationsInput
  updated_at: DateTimeFieldUpdateOperationsInput
  users: UsersUpdateOneRequiredWithoutCommentsNestedInput
}

input CommentsUpdateWithoutUsersInput {
  content: StringFieldUpdateOperationsInput
  created_at: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  parent_id: StringFieldUpdateOperationsInput
  target_type: EnumCommentTargetTypeFieldUpdateOperationsInput
  tasks: TasksUpdateOneRequiredWithoutCommentsNestedInput
  updated_at: DateTimeFieldUpdateOperationsInput
}

input CommentsUpsertWithWhereUniqueWithoutTasksInput {
  create: CommentsCreateWithoutTasksInput!
  update: CommentsUpdateWithoutTasksInput!
  where: CommentsWhereUniqueInput!
}

input CommentsUpsertWithWhereUniqueWithoutUsersInput {
  create: CommentsCreateWithoutUsersInput!
  update: CommentsUpdateWithoutUsersInput!
  where: CommentsWhereUniqueInput!
}

input CommentsWhereInput {
  AND: [CommentsWhereInput!]
  NOT: [CommentsWhereInput!]
  OR: [CommentsWhereInput!]
  content: StringFilter
  created_at: DateTimeFilter
  id: StringFilter
  owner_id: StringFilter
  parent_id: StringFilter
  target_id: StringFilter
  target_type: EnumCommentTargetTypeFilter
  tasks: TasksRelationFilter
  updated_at: DateTimeFilter
  users: UsersRelationFilter
}

input CommentsWhereUniqueInput {
  id: String
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input EnumActionGroupFieldUpdateOperationsInput {
  set: ActionGroup
}

input EnumActionGroupFilter {
  equals: ActionGroup
  in: [ActionGroup!]
  not: NestedEnumActionGroupFilter
  notIn: [ActionGroup!]
}

input EnumActionGroupWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumActionGroupFilter
  _min: NestedEnumActionGroupFilter
  equals: ActionGroup
  in: [ActionGroup!]
  not: NestedEnumActionGroupWithAggregatesFilter
  notIn: [ActionGroup!]
}

input EnumActionNameFieldUpdateOperationsInput {
  set: ActionName
}

input EnumActionNameFilter {
  equals: ActionName
  in: [ActionName!]
  not: NestedEnumActionNameFilter
  notIn: [ActionName!]
}

input EnumActionNameWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumActionNameFilter
  _min: NestedEnumActionNameFilter
  equals: ActionName
  in: [ActionName!]
  not: NestedEnumActionNameWithAggregatesFilter
  notIn: [ActionName!]
}

input EnumActionTargetTypeFieldUpdateOperationsInput {
  set: ActionTargetType
}

input EnumActionTargetTypeFilter {
  equals: ActionTargetType
  in: [ActionTargetType!]
  not: NestedEnumActionTargetTypeFilter
  notIn: [ActionTargetType!]
}

input EnumActionTargetTypeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumActionTargetTypeFilter
  _min: NestedEnumActionTargetTypeFilter
  equals: ActionTargetType
  in: [ActionTargetType!]
  not: NestedEnumActionTargetTypeWithAggregatesFilter
  notIn: [ActionTargetType!]
}

input EnumCommentTargetTypeFieldUpdateOperationsInput {
  set: CommentTargetType
}

input EnumCommentTargetTypeFilter {
  equals: CommentTargetType
  in: [CommentTargetType!]
  not: NestedEnumCommentTargetTypeFilter
  notIn: [CommentTargetType!]
}

input EnumCommentTargetTypeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumCommentTargetTypeFilter
  _min: NestedEnumCommentTargetTypeFilter
  equals: CommentTargetType
  in: [CommentTargetType!]
  not: NestedEnumCommentTargetTypeWithAggregatesFilter
  notIn: [CommentTargetType!]
}

input EnumTaskStateFieldUpdateOperationsInput {
  set: TaskState
}

input EnumTaskStateFilter {
  equals: TaskState
  in: [TaskState!]
  not: NestedEnumTaskStateFilter
  notIn: [TaskState!]
}

input EnumTaskStateWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumTaskStateFilter
  _min: NestedEnumTaskStateFilter
  equals: TaskState
  in: [TaskState!]
  not: NestedEnumTaskStateWithAggregatesFilter
  notIn: [TaskState!]
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

input JsonFilter {
  array_contains: JSON
  array_ends_with: JSON
  array_starts_with: JSON
  equals: JSON
  gt: JSON
  gte: JSON
  lt: JSON
  lte: JSON
  not: JSON
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

input JsonWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedJsonFilter
  _min: NestedJsonFilter
  array_contains: JSON
  array_ends_with: JSON
  array_starts_with: JSON
  equals: JSON
  gt: JSON
  gte: JSON
  lt: JSON
  lte: JSON
  not: JSON
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

type Mutation {
  createManyActions(data: [ActionsCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyAssignees(data: [AssigneesCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyComments(data: [CommentsCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyNotifications(data: [NotificationsCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyTasks(data: [TasksCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyUsers(data: [UsersCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOneActions(data: ActionsCreateInput!): Actions!
  createOneAssignees(data: AssigneesCreateInput!): Assignees!
  createOneComments(data: CommentsCreateInput!): Comments!
  createOneNotifications(data: NotificationsCreateInput!): Notifications!
  createOneTasks(data: TasksCreateInput!): Tasks!
  createOneUsers(data: UsersCreateInput!): Users!
  deleteManyActions(where: ActionsWhereInput): AffectedRowsOutput!
  deleteManyAssignees(where: AssigneesWhereInput): AffectedRowsOutput!
  deleteManyComments(where: CommentsWhereInput): AffectedRowsOutput!
  deleteManyNotifications(where: NotificationsWhereInput): AffectedRowsOutput!
  deleteManyTasks(where: TasksWhereInput): AffectedRowsOutput!
  deleteManyUsers(where: UsersWhereInput): AffectedRowsOutput!
  deleteOneActions(where: ActionsWhereUniqueInput!): Actions
  deleteOneAssignees(where: AssigneesWhereUniqueInput!): Assignees
  deleteOneComments(where: CommentsWhereUniqueInput!): Comments
  deleteOneNotifications(where: NotificationsWhereUniqueInput!): Notifications
  deleteOneTasks(where: TasksWhereUniqueInput!): Tasks
  deleteOneUsers(where: UsersWhereUniqueInput!): Users
  updateManyActions(data: ActionsUpdateManyMutationInput!, where: ActionsWhereInput): AffectedRowsOutput!
  updateManyAssignees(data: AssigneesUpdateManyMutationInput!, where: AssigneesWhereInput): AffectedRowsOutput!
  updateManyComments(data: CommentsUpdateManyMutationInput!, where: CommentsWhereInput): AffectedRowsOutput!
  updateManyNotifications(data: NotificationsUpdateManyMutationInput!, where: NotificationsWhereInput): AffectedRowsOutput!
  updateManyTasks(data: TasksUpdateManyMutationInput!, where: TasksWhereInput): AffectedRowsOutput!
  updateManyUsers(data: UsersUpdateManyMutationInput!, where: UsersWhereInput): AffectedRowsOutput!
  updateOneActions(data: ActionsUpdateInput!, where: ActionsWhereUniqueInput!): Actions
  updateOneAssignees(data: AssigneesUpdateInput!, where: AssigneesWhereUniqueInput!): Assignees
  updateOneComments(data: CommentsUpdateInput!, where: CommentsWhereUniqueInput!): Comments
  updateOneNotifications(data: NotificationsUpdateInput!, where: NotificationsWhereUniqueInput!): Notifications
  updateOneTasks(data: TasksUpdateInput!, where: TasksWhereUniqueInput!): Tasks
  updateOneUsers(data: UsersUpdateInput!, where: UsersWhereUniqueInput!): Users
  upsertOneActions(create: ActionsCreateInput!, update: ActionsUpdateInput!, where: ActionsWhereUniqueInput!): Actions!
  upsertOneAssignees(create: AssigneesCreateInput!, update: AssigneesUpdateInput!, where: AssigneesWhereUniqueInput!): Assignees!
  upsertOneComments(create: CommentsCreateInput!, update: CommentsUpdateInput!, where: CommentsWhereUniqueInput!): Comments!
  upsertOneNotifications(create: NotificationsCreateInput!, update: NotificationsUpdateInput!, where: NotificationsWhereUniqueInput!): Notifications!
  upsertOneTasks(create: TasksCreateInput!, update: TasksUpdateInput!, where: TasksWhereUniqueInput!): Tasks!
  upsertOneUsers(create: UsersCreateInput!, update: UsersUpdateInput!, where: UsersWhereUniqueInput!): Users!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedEnumActionGroupFilter {
  equals: ActionGroup
  in: [ActionGroup!]
  not: NestedEnumActionGroupFilter
  notIn: [ActionGroup!]
}

input NestedEnumActionGroupWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumActionGroupFilter
  _min: NestedEnumActionGroupFilter
  equals: ActionGroup
  in: [ActionGroup!]
  not: NestedEnumActionGroupWithAggregatesFilter
  notIn: [ActionGroup!]
}

input NestedEnumActionNameFilter {
  equals: ActionName
  in: [ActionName!]
  not: NestedEnumActionNameFilter
  notIn: [ActionName!]
}

input NestedEnumActionNameWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumActionNameFilter
  _min: NestedEnumActionNameFilter
  equals: ActionName
  in: [ActionName!]
  not: NestedEnumActionNameWithAggregatesFilter
  notIn: [ActionName!]
}

input NestedEnumActionTargetTypeFilter {
  equals: ActionTargetType
  in: [ActionTargetType!]
  not: NestedEnumActionTargetTypeFilter
  notIn: [ActionTargetType!]
}

input NestedEnumActionTargetTypeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumActionTargetTypeFilter
  _min: NestedEnumActionTargetTypeFilter
  equals: ActionTargetType
  in: [ActionTargetType!]
  not: NestedEnumActionTargetTypeWithAggregatesFilter
  notIn: [ActionTargetType!]
}

input NestedEnumCommentTargetTypeFilter {
  equals: CommentTargetType
  in: [CommentTargetType!]
  not: NestedEnumCommentTargetTypeFilter
  notIn: [CommentTargetType!]
}

input NestedEnumCommentTargetTypeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumCommentTargetTypeFilter
  _min: NestedEnumCommentTargetTypeFilter
  equals: CommentTargetType
  in: [CommentTargetType!]
  not: NestedEnumCommentTargetTypeWithAggregatesFilter
  notIn: [CommentTargetType!]
}

input NestedEnumTaskStateFilter {
  equals: TaskState
  in: [TaskState!]
  not: NestedEnumTaskStateFilter
  notIn: [TaskState!]
}

input NestedEnumTaskStateWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumTaskStateFilter
  _min: NestedEnumTaskStateFilter
  equals: TaskState
  in: [TaskState!]
  not: NestedEnumTaskStateWithAggregatesFilter
  notIn: [TaskState!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedJsonFilter {
  array_contains: JSON
  array_ends_with: JSON
  array_starts_with: JSON
  equals: JSON
  gt: JSON
  gte: JSON
  lt: JSON
  lte: JSON
  not: JSON
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Notifications {
  action_id: String!
  actions: Actions!
  id: ID!
  readed_at: DateTime!
  user_id: String!
  users: Users!
}

type NotificationsCountAggregate {
  _all: Int!
  action_id: Int!
  id: Int!
  readed_at: Int!
  user_id: Int!
}

input NotificationsCountOrderByAggregateInput {
  action_id: SortOrder
  id: SortOrder
  readed_at: SortOrder
  user_id: SortOrder
}

input NotificationsCreateInput {
  actions: ActionsCreateNestedOneWithoutNotificationsInput
  id: String
  readed_at: DateTime!
  users: UsersCreateNestedOneWithoutNotificationsInput
}

input NotificationsCreateManyActionsInput {
  id: String
  readed_at: DateTime!
  user_id: String
}

input NotificationsCreateManyActionsInputEnvelope {
  data: [NotificationsCreateManyActionsInput!]!
  skipDuplicates: Boolean
}

input NotificationsCreateManyInput {
  action_id: String
  id: String
  readed_at: DateTime!
  user_id: String
}

input NotificationsCreateManyUsersInput {
  action_id: String
  id: String
  readed_at: DateTime!
}

input NotificationsCreateManyUsersInputEnvelope {
  data: [NotificationsCreateManyUsersInput!]!
  skipDuplicates: Boolean
}

input NotificationsCreateNestedManyWithoutActionsInput {
  connect: [NotificationsWhereUniqueInput!]
  connectOrCreate: [NotificationsCreateOrConnectWithoutActionsInput!]
  create: [NotificationsCreateWithoutActionsInput!]
  createMany: NotificationsCreateManyActionsInputEnvelope
}

input NotificationsCreateNestedManyWithoutUsersInput {
  connect: [NotificationsWhereUniqueInput!]
  connectOrCreate: [NotificationsCreateOrConnectWithoutUsersInput!]
  create: [NotificationsCreateWithoutUsersInput!]
  createMany: NotificationsCreateManyUsersInputEnvelope
}

input NotificationsCreateOrConnectWithoutActionsInput {
  create: NotificationsCreateWithoutActionsInput!
  where: NotificationsWhereUniqueInput!
}

input NotificationsCreateOrConnectWithoutUsersInput {
  create: NotificationsCreateWithoutUsersInput!
  where: NotificationsWhereUniqueInput!
}

input NotificationsCreateWithoutActionsInput {
  id: String
  readed_at: DateTime!
  users: UsersCreateNestedOneWithoutNotificationsInput
}

input NotificationsCreateWithoutUsersInput {
  actions: ActionsCreateNestedOneWithoutNotificationsInput
  id: String
  readed_at: DateTime!
}

type NotificationsGroupBy {
  _count: NotificationsCountAggregate
  _max: NotificationsMaxAggregate
  _min: NotificationsMinAggregate
  action_id: String!
  id: String!
  readed_at: DateTime!
  user_id: String!
}

input NotificationsListRelationFilter {
  every: NotificationsWhereInput
  none: NotificationsWhereInput
  some: NotificationsWhereInput
}

type NotificationsMaxAggregate {
  action_id: String
  id: String
  readed_at: DateTime
  user_id: String
}

input NotificationsMaxOrderByAggregateInput {
  action_id: SortOrder
  id: SortOrder
  readed_at: SortOrder
  user_id: SortOrder
}

type NotificationsMinAggregate {
  action_id: String
  id: String
  readed_at: DateTime
  user_id: String
}

input NotificationsMinOrderByAggregateInput {
  action_id: SortOrder
  id: SortOrder
  readed_at: SortOrder
  user_id: SortOrder
}

input NotificationsOrderByRelationAggregateInput {
  _count: SortOrder
}

input NotificationsOrderByWithAggregationInput {
  _count: NotificationsCountOrderByAggregateInput
  _max: NotificationsMaxOrderByAggregateInput
  _min: NotificationsMinOrderByAggregateInput
  action_id: SortOrder
  id: SortOrder
  readed_at: SortOrder
  user_id: SortOrder
}

input NotificationsOrderByWithRelationInput {
  action_id: SortOrder
  actions: ActionsOrderByWithRelationInput
  id: SortOrder
  readed_at: SortOrder
  user_id: SortOrder
  users: UsersOrderByWithRelationInput
}

enum NotificationsScalarFieldEnum {
  action_id
  id
  readed_at
  user_id
}

input NotificationsScalarWhereInput {
  AND: [NotificationsScalarWhereInput!]
  NOT: [NotificationsScalarWhereInput!]
  OR: [NotificationsScalarWhereInput!]
  action_id: StringFilter
  id: StringFilter
  readed_at: DateTimeFilter
  user_id: StringFilter
}

input NotificationsScalarWhereWithAggregatesInput {
  AND: [NotificationsScalarWhereWithAggregatesInput!]
  NOT: [NotificationsScalarWhereWithAggregatesInput!]
  OR: [NotificationsScalarWhereWithAggregatesInput!]
  action_id: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  readed_at: DateTimeWithAggregatesFilter
  user_id: StringWithAggregatesFilter
}

input NotificationsUpdateInput {
  actions: ActionsUpdateOneRequiredWithoutNotificationsNestedInput
  id: StringFieldUpdateOperationsInput
  readed_at: DateTimeFieldUpdateOperationsInput
  users: UsersUpdateOneRequiredWithoutNotificationsNestedInput
}

input NotificationsUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  readed_at: DateTimeFieldUpdateOperationsInput
}

input NotificationsUpdateManyWithWhereWithoutActionsInput {
  data: NotificationsUpdateManyMutationInput!
  where: NotificationsScalarWhereInput!
}

input NotificationsUpdateManyWithWhereWithoutUsersInput {
  data: NotificationsUpdateManyMutationInput!
  where: NotificationsScalarWhereInput!
}

input NotificationsUpdateManyWithoutActionsNestedInput {
  connect: [NotificationsWhereUniqueInput!]
  connectOrCreate: [NotificationsCreateOrConnectWithoutActionsInput!]
  create: [NotificationsCreateWithoutActionsInput!]
  createMany: NotificationsCreateManyActionsInputEnvelope
  delete: [NotificationsWhereUniqueInput!]
  deleteMany: [NotificationsScalarWhereInput!]
  disconnect: [NotificationsWhereUniqueInput!]
  set: [NotificationsWhereUniqueInput!]
  update: [NotificationsUpdateWithWhereUniqueWithoutActionsInput!]
  updateMany: [NotificationsUpdateManyWithWhereWithoutActionsInput!]
  upsert: [NotificationsUpsertWithWhereUniqueWithoutActionsInput!]
}

input NotificationsUpdateManyWithoutUsersNestedInput {
  connect: [NotificationsWhereUniqueInput!]
  connectOrCreate: [NotificationsCreateOrConnectWithoutUsersInput!]
  create: [NotificationsCreateWithoutUsersInput!]
  createMany: NotificationsCreateManyUsersInputEnvelope
  delete: [NotificationsWhereUniqueInput!]
  deleteMany: [NotificationsScalarWhereInput!]
  disconnect: [NotificationsWhereUniqueInput!]
  set: [NotificationsWhereUniqueInput!]
  update: [NotificationsUpdateWithWhereUniqueWithoutUsersInput!]
  updateMany: [NotificationsUpdateManyWithWhereWithoutUsersInput!]
  upsert: [NotificationsUpsertWithWhereUniqueWithoutUsersInput!]
}

input NotificationsUpdateWithWhereUniqueWithoutActionsInput {
  data: NotificationsUpdateWithoutActionsInput!
  where: NotificationsWhereUniqueInput!
}

input NotificationsUpdateWithWhereUniqueWithoutUsersInput {
  data: NotificationsUpdateWithoutUsersInput!
  where: NotificationsWhereUniqueInput!
}

input NotificationsUpdateWithoutActionsInput {
  id: StringFieldUpdateOperationsInput
  readed_at: DateTimeFieldUpdateOperationsInput
  users: UsersUpdateOneRequiredWithoutNotificationsNestedInput
}

input NotificationsUpdateWithoutUsersInput {
  actions: ActionsUpdateOneRequiredWithoutNotificationsNestedInput
  id: StringFieldUpdateOperationsInput
  readed_at: DateTimeFieldUpdateOperationsInput
}

input NotificationsUpsertWithWhereUniqueWithoutActionsInput {
  create: NotificationsCreateWithoutActionsInput!
  update: NotificationsUpdateWithoutActionsInput!
  where: NotificationsWhereUniqueInput!
}

input NotificationsUpsertWithWhereUniqueWithoutUsersInput {
  create: NotificationsCreateWithoutUsersInput!
  update: NotificationsUpdateWithoutUsersInput!
  where: NotificationsWhereUniqueInput!
}

input NotificationsWhereInput {
  AND: [NotificationsWhereInput!]
  NOT: [NotificationsWhereInput!]
  OR: [NotificationsWhereInput!]
  action_id: StringFilter
  actions: ActionsRelationFilter
  id: StringFilter
  readed_at: DateTimeFilter
  user_id: StringFilter
  users: UsersRelationFilter
}

input NotificationsWhereUniqueInput {
  id: String
}

type Query {
  aggregateActions(cursor: ActionsWhereUniqueInput, orderBy: [ActionsOrderByWithRelationInput!], skip: Int, take: Int, where: ActionsWhereInput): AggregateActions!
  aggregateAssignees(cursor: AssigneesWhereUniqueInput, orderBy: [AssigneesOrderByWithRelationInput!], skip: Int, take: Int, where: AssigneesWhereInput): AggregateAssignees!
  aggregateComments(cursor: CommentsWhereUniqueInput, orderBy: [CommentsOrderByWithRelationInput!], skip: Int, take: Int, where: CommentsWhereInput): AggregateComments!
  aggregateNotifications(cursor: NotificationsWhereUniqueInput, orderBy: [NotificationsOrderByWithRelationInput!], skip: Int, take: Int, where: NotificationsWhereInput): AggregateNotifications!
  aggregateTasks(cursor: TasksWhereUniqueInput, orderBy: [TasksOrderByWithRelationInput!], skip: Int, take: Int, where: TasksWhereInput): AggregateTasks!
  aggregateUsers(cursor: UsersWhereUniqueInput, orderBy: [UsersOrderByWithRelationInput!], skip: Int, take: Int, where: UsersWhereInput): AggregateUsers!
  findFirstActions(cursor: ActionsWhereUniqueInput, distinct: [ActionsScalarFieldEnum!], orderBy: [ActionsOrderByWithRelationInput!], skip: Int, take: Int, where: ActionsWhereInput): Actions
  findFirstActionsOrThrow(cursor: ActionsWhereUniqueInput, distinct: [ActionsScalarFieldEnum!], orderBy: [ActionsOrderByWithRelationInput!], skip: Int, take: Int, where: ActionsWhereInput): Actions
  findFirstAssignees(cursor: AssigneesWhereUniqueInput, distinct: [AssigneesScalarFieldEnum!], orderBy: [AssigneesOrderByWithRelationInput!], skip: Int, take: Int, where: AssigneesWhereInput): Assignees
  findFirstAssigneesOrThrow(cursor: AssigneesWhereUniqueInput, distinct: [AssigneesScalarFieldEnum!], orderBy: [AssigneesOrderByWithRelationInput!], skip: Int, take: Int, where: AssigneesWhereInput): Assignees
  findFirstComments(cursor: CommentsWhereUniqueInput, distinct: [CommentsScalarFieldEnum!], orderBy: [CommentsOrderByWithRelationInput!], skip: Int, take: Int, where: CommentsWhereInput): Comments
  findFirstCommentsOrThrow(cursor: CommentsWhereUniqueInput, distinct: [CommentsScalarFieldEnum!], orderBy: [CommentsOrderByWithRelationInput!], skip: Int, take: Int, where: CommentsWhereInput): Comments
  findFirstNotifications(cursor: NotificationsWhereUniqueInput, distinct: [NotificationsScalarFieldEnum!], orderBy: [NotificationsOrderByWithRelationInput!], skip: Int, take: Int, where: NotificationsWhereInput): Notifications
  findFirstNotificationsOrThrow(cursor: NotificationsWhereUniqueInput, distinct: [NotificationsScalarFieldEnum!], orderBy: [NotificationsOrderByWithRelationInput!], skip: Int, take: Int, where: NotificationsWhereInput): Notifications
  findFirstTasks(cursor: TasksWhereUniqueInput, distinct: [TasksScalarFieldEnum!], orderBy: [TasksOrderByWithRelationInput!], skip: Int, take: Int, where: TasksWhereInput): Tasks
  findFirstTasksOrThrow(cursor: TasksWhereUniqueInput, distinct: [TasksScalarFieldEnum!], orderBy: [TasksOrderByWithRelationInput!], skip: Int, take: Int, where: TasksWhereInput): Tasks
  findFirstUsers(cursor: UsersWhereUniqueInput, distinct: [UsersScalarFieldEnum!], orderBy: [UsersOrderByWithRelationInput!], skip: Int, take: Int, where: UsersWhereInput): Users
  findFirstUsersOrThrow(cursor: UsersWhereUniqueInput, distinct: [UsersScalarFieldEnum!], orderBy: [UsersOrderByWithRelationInput!], skip: Int, take: Int, where: UsersWhereInput): Users
  findManyActions(cursor: ActionsWhereUniqueInput, distinct: [ActionsScalarFieldEnum!], orderBy: [ActionsOrderByWithRelationInput!], skip: Int, take: Int, where: ActionsWhereInput): [Actions!]!
  findManyAssignees(cursor: AssigneesWhereUniqueInput, distinct: [AssigneesScalarFieldEnum!], orderBy: [AssigneesOrderByWithRelationInput!], skip: Int, take: Int, where: AssigneesWhereInput): [Assignees!]!
  findManyComments(cursor: CommentsWhereUniqueInput, distinct: [CommentsScalarFieldEnum!], orderBy: [CommentsOrderByWithRelationInput!], skip: Int, take: Int, where: CommentsWhereInput): [Comments!]!
  findManyNotifications(cursor: NotificationsWhereUniqueInput, distinct: [NotificationsScalarFieldEnum!], orderBy: [NotificationsOrderByWithRelationInput!], skip: Int, take: Int, where: NotificationsWhereInput): [Notifications!]!
  findManyTasks(cursor: TasksWhereUniqueInput, distinct: [TasksScalarFieldEnum!], orderBy: [TasksOrderByWithRelationInput!], skip: Int, take: Int, where: TasksWhereInput): [Tasks!]!
  findManyUsers(cursor: UsersWhereUniqueInput, distinct: [UsersScalarFieldEnum!], orderBy: [UsersOrderByWithRelationInput!], skip: Int, take: Int, where: UsersWhereInput): [Users!]!
  findUniqueActions(where: ActionsWhereUniqueInput!): Actions
  findUniqueActionsOrThrow(where: ActionsWhereUniqueInput!): Actions
  findUniqueAssignees(where: AssigneesWhereUniqueInput!): Assignees
  findUniqueAssigneesOrThrow(where: AssigneesWhereUniqueInput!): Assignees
  findUniqueComments(where: CommentsWhereUniqueInput!): Comments
  findUniqueCommentsOrThrow(where: CommentsWhereUniqueInput!): Comments
  findUniqueNotifications(where: NotificationsWhereUniqueInput!): Notifications
  findUniqueNotificationsOrThrow(where: NotificationsWhereUniqueInput!): Notifications
  findUniqueTasks(where: TasksWhereUniqueInput!): Tasks
  findUniqueTasksOrThrow(where: TasksWhereUniqueInput!): Tasks
  findUniqueUsers(where: UsersWhereUniqueInput!): Users
  findUniqueUsersOrThrow(where: UsersWhereUniqueInput!): Users
  groupByActions(by: [ActionsScalarFieldEnum!]!, having: ActionsScalarWhereWithAggregatesInput, orderBy: [ActionsOrderByWithAggregationInput!], skip: Int, take: Int, where: ActionsWhereInput): [ActionsGroupBy!]!
  groupByAssignees(by: [AssigneesScalarFieldEnum!]!, having: AssigneesScalarWhereWithAggregatesInput, orderBy: [AssigneesOrderByWithAggregationInput!], skip: Int, take: Int, where: AssigneesWhereInput): [AssigneesGroupBy!]!
  groupByComments(by: [CommentsScalarFieldEnum!]!, having: CommentsScalarWhereWithAggregatesInput, orderBy: [CommentsOrderByWithAggregationInput!], skip: Int, take: Int, where: CommentsWhereInput): [CommentsGroupBy!]!
  groupByNotifications(by: [NotificationsScalarFieldEnum!]!, having: NotificationsScalarWhereWithAggregatesInput, orderBy: [NotificationsOrderByWithAggregationInput!], skip: Int, take: Int, where: NotificationsWhereInput): [NotificationsGroupBy!]!
  groupByTasks(by: [TasksScalarFieldEnum!]!, having: TasksScalarWhereWithAggregatesInput, orderBy: [TasksOrderByWithAggregationInput!], skip: Int, take: Int, where: TasksWhereInput): [TasksGroupBy!]!
  groupByUsers(by: [UsersScalarFieldEnum!]!, having: UsersScalarWhereWithAggregatesInput, orderBy: [UsersOrderByWithAggregationInput!], skip: Int, take: Int, where: UsersWhereInput): [UsersGroupBy!]!
}

enum QueryMode {
  default
  insensitive
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Subscription {
  hello: String!
}

enum TaskState {
  DONE
  IN_PROGRESS
  PENDING
}

type Tasks {
  _count: TasksCount
  assignees: Assignees
  comments(cursor: CommentsWhereUniqueInput, distinct: [CommentsScalarFieldEnum!], orderBy: [CommentsOrderByWithRelationInput!], skip: Int, take: Int, where: CommentsWhereInput): [Comments!]!
  created_at: DateTime!
  description: String!
  due_at: DateTime!
  id: ID!
  owner_id: String!
  state: TaskState!
  title: String!
  updated_at: DateTime!
  users: Users!
}

type TasksCount {
  comments: Int!
}

type TasksCountAggregate {
  _all: Int!
  created_at: Int!
  description: Int!
  due_at: Int!
  id: Int!
  owner_id: Int!
  state: Int!
  title: Int!
  updated_at: Int!
}

input TasksCountOrderByAggregateInput {
  created_at: SortOrder
  description: SortOrder
  due_at: SortOrder
  id: SortOrder
  owner_id: SortOrder
  state: SortOrder
  title: SortOrder
  updated_at: SortOrder
}

input TasksCreateInput {
  assignees: AssigneesCreateNestedOneWithoutTasksInput
  comments: CommentsCreateNestedManyWithoutTasksInput
  created_at: DateTime!
  description: String!
  due_at: DateTime!
  id: String
  state: TaskState!
  title: String!
  updated_at: DateTime!
  users: UsersCreateNestedOneWithoutTasksInput
}

input TasksCreateManyInput {
  created_at: DateTime!
  description: String!
  due_at: DateTime!
  id: String
  owner_id: String
  state: TaskState!
  title: String!
  updated_at: DateTime!
}

input TasksCreateManyUsersInput {
  created_at: DateTime!
  description: String!
  due_at: DateTime!
  id: String
  state: TaskState!
  title: String!
  updated_at: DateTime!
}

input TasksCreateManyUsersInputEnvelope {
  data: [TasksCreateManyUsersInput!]!
  skipDuplicates: Boolean
}

input TasksCreateNestedManyWithoutUsersInput {
  connect: [TasksWhereUniqueInput!]
  connectOrCreate: [TasksCreateOrConnectWithoutUsersInput!]
  create: [TasksCreateWithoutUsersInput!]
  createMany: TasksCreateManyUsersInputEnvelope
}

input TasksCreateNestedOneWithoutAssigneesInput {
  connect: TasksWhereUniqueInput
  connectOrCreate: TasksCreateOrConnectWithoutAssigneesInput
  create: TasksCreateWithoutAssigneesInput
}

input TasksCreateNestedOneWithoutCommentsInput {
  connect: TasksWhereUniqueInput
  connectOrCreate: TasksCreateOrConnectWithoutCommentsInput
  create: TasksCreateWithoutCommentsInput
}

input TasksCreateOrConnectWithoutAssigneesInput {
  create: TasksCreateWithoutAssigneesInput!
  where: TasksWhereUniqueInput!
}

input TasksCreateOrConnectWithoutCommentsInput {
  create: TasksCreateWithoutCommentsInput!
  where: TasksWhereUniqueInput!
}

input TasksCreateOrConnectWithoutUsersInput {
  create: TasksCreateWithoutUsersInput!
  where: TasksWhereUniqueInput!
}

input TasksCreateWithoutAssigneesInput {
  comments: CommentsCreateNestedManyWithoutTasksInput
  created_at: DateTime!
  description: String!
  due_at: DateTime!
  id: String
  state: TaskState!
  title: String!
  updated_at: DateTime!
  users: UsersCreateNestedOneWithoutTasksInput
}

input TasksCreateWithoutCommentsInput {
  assignees: AssigneesCreateNestedOneWithoutTasksInput
  created_at: DateTime!
  description: String!
  due_at: DateTime!
  id: String
  state: TaskState!
  title: String!
  updated_at: DateTime!
  users: UsersCreateNestedOneWithoutTasksInput
}

input TasksCreateWithoutUsersInput {
  assignees: AssigneesCreateNestedOneWithoutTasksInput
  comments: CommentsCreateNestedManyWithoutTasksInput
  created_at: DateTime!
  description: String!
  due_at: DateTime!
  id: String
  state: TaskState!
  title: String!
  updated_at: DateTime!
}

type TasksGroupBy {
  _count: TasksCountAggregate
  _max: TasksMaxAggregate
  _min: TasksMinAggregate
  created_at: DateTime!
  description: String!
  due_at: DateTime!
  id: String!
  owner_id: String!
  state: TaskState!
  title: String!
  updated_at: DateTime!
}

input TasksListRelationFilter {
  every: TasksWhereInput
  none: TasksWhereInput
  some: TasksWhereInput
}

type TasksMaxAggregate {
  created_at: DateTime
  description: String
  due_at: DateTime
  id: String
  owner_id: String
  state: TaskState
  title: String
  updated_at: DateTime
}

input TasksMaxOrderByAggregateInput {
  created_at: SortOrder
  description: SortOrder
  due_at: SortOrder
  id: SortOrder
  owner_id: SortOrder
  state: SortOrder
  title: SortOrder
  updated_at: SortOrder
}

type TasksMinAggregate {
  created_at: DateTime
  description: String
  due_at: DateTime
  id: String
  owner_id: String
  state: TaskState
  title: String
  updated_at: DateTime
}

input TasksMinOrderByAggregateInput {
  created_at: SortOrder
  description: SortOrder
  due_at: SortOrder
  id: SortOrder
  owner_id: SortOrder
  state: SortOrder
  title: SortOrder
  updated_at: SortOrder
}

input TasksOrderByRelationAggregateInput {
  _count: SortOrder
}

input TasksOrderByWithAggregationInput {
  _count: TasksCountOrderByAggregateInput
  _max: TasksMaxOrderByAggregateInput
  _min: TasksMinOrderByAggregateInput
  created_at: SortOrder
  description: SortOrder
  due_at: SortOrder
  id: SortOrder
  owner_id: SortOrder
  state: SortOrder
  title: SortOrder
  updated_at: SortOrder
}

input TasksOrderByWithRelationInput {
  assignees: AssigneesOrderByWithRelationInput
  comments: CommentsOrderByRelationAggregateInput
  created_at: SortOrder
  description: SortOrder
  due_at: SortOrder
  id: SortOrder
  owner_id: SortOrder
  state: SortOrder
  title: SortOrder
  updated_at: SortOrder
  users: UsersOrderByWithRelationInput
}

input TasksRelationFilter {
  is: TasksWhereInput
  isNot: TasksWhereInput
}

enum TasksScalarFieldEnum {
  created_at
  description
  due_at
  id
  owner_id
  state
  title
  updated_at
}

input TasksScalarWhereInput {
  AND: [TasksScalarWhereInput!]
  NOT: [TasksScalarWhereInput!]
  OR: [TasksScalarWhereInput!]
  created_at: DateTimeFilter
  description: StringFilter
  due_at: DateTimeFilter
  id: StringFilter
  owner_id: StringFilter
  state: EnumTaskStateFilter
  title: StringFilter
  updated_at: DateTimeFilter
}

input TasksScalarWhereWithAggregatesInput {
  AND: [TasksScalarWhereWithAggregatesInput!]
  NOT: [TasksScalarWhereWithAggregatesInput!]
  OR: [TasksScalarWhereWithAggregatesInput!]
  created_at: DateTimeWithAggregatesFilter
  description: StringWithAggregatesFilter
  due_at: DateTimeWithAggregatesFilter
  id: StringWithAggregatesFilter
  owner_id: StringWithAggregatesFilter
  state: EnumTaskStateWithAggregatesFilter
  title: StringWithAggregatesFilter
  updated_at: DateTimeWithAggregatesFilter
}

input TasksUpdateInput {
  assignees: AssigneesUpdateOneWithoutTasksNestedInput
  comments: CommentsUpdateManyWithoutTasksNestedInput
  created_at: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  due_at: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  state: EnumTaskStateFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updated_at: DateTimeFieldUpdateOperationsInput
  users: UsersUpdateOneRequiredWithoutTasksNestedInput
}

input TasksUpdateManyMutationInput {
  created_at: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  due_at: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  state: EnumTaskStateFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updated_at: DateTimeFieldUpdateOperationsInput
}

input TasksUpdateManyWithWhereWithoutUsersInput {
  data: TasksUpdateManyMutationInput!
  where: TasksScalarWhereInput!
}

input TasksUpdateManyWithoutUsersNestedInput {
  connect: [TasksWhereUniqueInput!]
  connectOrCreate: [TasksCreateOrConnectWithoutUsersInput!]
  create: [TasksCreateWithoutUsersInput!]
  createMany: TasksCreateManyUsersInputEnvelope
  delete: [TasksWhereUniqueInput!]
  deleteMany: [TasksScalarWhereInput!]
  disconnect: [TasksWhereUniqueInput!]
  set: [TasksWhereUniqueInput!]
  update: [TasksUpdateWithWhereUniqueWithoutUsersInput!]
  updateMany: [TasksUpdateManyWithWhereWithoutUsersInput!]
  upsert: [TasksUpsertWithWhereUniqueWithoutUsersInput!]
}

input TasksUpdateOneRequiredWithoutAssigneesNestedInput {
  connect: TasksWhereUniqueInput
  connectOrCreate: TasksCreateOrConnectWithoutAssigneesInput
  create: TasksCreateWithoutAssigneesInput
  update: TasksUpdateWithoutAssigneesInput
  upsert: TasksUpsertWithoutAssigneesInput
}

input TasksUpdateOneRequiredWithoutCommentsNestedInput {
  connect: TasksWhereUniqueInput
  connectOrCreate: TasksCreateOrConnectWithoutCommentsInput
  create: TasksCreateWithoutCommentsInput
  update: TasksUpdateWithoutCommentsInput
  upsert: TasksUpsertWithoutCommentsInput
}

input TasksUpdateWithWhereUniqueWithoutUsersInput {
  data: TasksUpdateWithoutUsersInput!
  where: TasksWhereUniqueInput!
}

input TasksUpdateWithoutAssigneesInput {
  comments: CommentsUpdateManyWithoutTasksNestedInput
  created_at: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  due_at: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  state: EnumTaskStateFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updated_at: DateTimeFieldUpdateOperationsInput
  users: UsersUpdateOneRequiredWithoutTasksNestedInput
}

input TasksUpdateWithoutCommentsInput {
  assignees: AssigneesUpdateOneWithoutTasksNestedInput
  created_at: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  due_at: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  state: EnumTaskStateFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updated_at: DateTimeFieldUpdateOperationsInput
  users: UsersUpdateOneRequiredWithoutTasksNestedInput
}

input TasksUpdateWithoutUsersInput {
  assignees: AssigneesUpdateOneWithoutTasksNestedInput
  comments: CommentsUpdateManyWithoutTasksNestedInput
  created_at: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  due_at: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  state: EnumTaskStateFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updated_at: DateTimeFieldUpdateOperationsInput
}

input TasksUpsertWithWhereUniqueWithoutUsersInput {
  create: TasksCreateWithoutUsersInput!
  update: TasksUpdateWithoutUsersInput!
  where: TasksWhereUniqueInput!
}

input TasksUpsertWithoutAssigneesInput {
  create: TasksCreateWithoutAssigneesInput!
  update: TasksUpdateWithoutAssigneesInput!
}

input TasksUpsertWithoutCommentsInput {
  create: TasksCreateWithoutCommentsInput!
  update: TasksUpdateWithoutCommentsInput!
}

input TasksWhereInput {
  AND: [TasksWhereInput!]
  NOT: [TasksWhereInput!]
  OR: [TasksWhereInput!]
  assignees: AssigneesRelationFilter
  comments: CommentsListRelationFilter
  created_at: DateTimeFilter
  description: StringFilter
  due_at: DateTimeFilter
  id: StringFilter
  owner_id: StringFilter
  state: EnumTaskStateFilter
  title: StringFilter
  updated_at: DateTimeFilter
  users: UsersRelationFilter
}

input TasksWhereUniqueInput {
  id: String
}

type Users {
  _count: UsersCount
  active: Boolean!
  assignees: Assignees
  comments(cursor: CommentsWhereUniqueInput, distinct: [CommentsScalarFieldEnum!], orderBy: [CommentsOrderByWithRelationInput!], skip: Int, take: Int, where: CommentsWhereInput): [Comments!]!
  created_at: DateTime!
  email: String!
  id: ID!
  last_sign_in_at: DateTime!
  notifications(cursor: NotificationsWhereUniqueInput, distinct: [NotificationsScalarFieldEnum!], orderBy: [NotificationsOrderByWithRelationInput!], skip: Int, take: Int, where: NotificationsWhereInput): [Notifications!]!
  preferences: JSON!
  tasks(cursor: TasksWhereUniqueInput, distinct: [TasksScalarFieldEnum!], orderBy: [TasksOrderByWithRelationInput!], skip: Int, take: Int, where: TasksWhereInput): [Tasks!]!
  updated_at: DateTime!
}

type UsersCount {
  comments: Int!
  notifications: Int!
  tasks: Int!
}

type UsersCountAggregate {
  _all: Int!
  active: Int!
  created_at: Int!
  email: Int!
  id: Int!
  last_sign_in_at: Int!
  password: Int!
  password_digest: Int!
  preferences: Int!
  updated_at: Int!
}

input UsersCountOrderByAggregateInput {
  active: SortOrder
  created_at: SortOrder
  email: SortOrder
  id: SortOrder
  last_sign_in_at: SortOrder
  password: SortOrder
  preferences: SortOrder
  updated_at: SortOrder
}

input UsersCreateInput {
  active: Boolean!
  assignees: AssigneesCreateNestedOneWithoutUsersInput
  comments: CommentsCreateNestedManyWithoutUsersInput
  created_at: DateTime!
  email: String!
  id: String
  last_sign_in_at: DateTime!
  notifications: NotificationsCreateNestedManyWithoutUsersInput
  password: String!
  preferences: JSON!
  tasks: TasksCreateNestedManyWithoutUsersInput
  updated_at: DateTime!
}

input UsersCreateManyInput {
  active: Boolean!
  created_at: DateTime!
  email: String!
  id: String
  last_sign_in_at: DateTime!
  password: String!
  preferences: JSON!
  updated_at: DateTime!
}

input UsersCreateNestedOneWithoutAssigneesInput {
  connect: UsersWhereUniqueInput
  connectOrCreate: UsersCreateOrConnectWithoutAssigneesInput
  create: UsersCreateWithoutAssigneesInput
}

input UsersCreateNestedOneWithoutCommentsInput {
  connect: UsersWhereUniqueInput
  connectOrCreate: UsersCreateOrConnectWithoutCommentsInput
  create: UsersCreateWithoutCommentsInput
}

input UsersCreateNestedOneWithoutNotificationsInput {
  connect: UsersWhereUniqueInput
  connectOrCreate: UsersCreateOrConnectWithoutNotificationsInput
  create: UsersCreateWithoutNotificationsInput
}

input UsersCreateNestedOneWithoutTasksInput {
  connect: UsersWhereUniqueInput
  connectOrCreate: UsersCreateOrConnectWithoutTasksInput
  create: UsersCreateWithoutTasksInput
}

input UsersCreateOrConnectWithoutAssigneesInput {
  create: UsersCreateWithoutAssigneesInput!
  where: UsersWhereUniqueInput!
}

input UsersCreateOrConnectWithoutCommentsInput {
  create: UsersCreateWithoutCommentsInput!
  where: UsersWhereUniqueInput!
}

input UsersCreateOrConnectWithoutNotificationsInput {
  create: UsersCreateWithoutNotificationsInput!
  where: UsersWhereUniqueInput!
}

input UsersCreateOrConnectWithoutTasksInput {
  create: UsersCreateWithoutTasksInput!
  where: UsersWhereUniqueInput!
}

input UsersCreateWithoutAssigneesInput {
  active: Boolean!
  comments: CommentsCreateNestedManyWithoutUsersInput
  created_at: DateTime!
  email: String!
  id: String
  last_sign_in_at: DateTime!
  notifications: NotificationsCreateNestedManyWithoutUsersInput
  password: String!
  preferences: JSON!
  tasks: TasksCreateNestedManyWithoutUsersInput
  updated_at: DateTime!
}

input UsersCreateWithoutCommentsInput {
  active: Boolean!
  assignees: AssigneesCreateNestedOneWithoutUsersInput
  created_at: DateTime!
  email: String!
  id: String
  last_sign_in_at: DateTime!
  notifications: NotificationsCreateNestedManyWithoutUsersInput
  password: String!
  preferences: JSON!
  tasks: TasksCreateNestedManyWithoutUsersInput
  updated_at: DateTime!
}

input UsersCreateWithoutNotificationsInput {
  active: Boolean!
  assignees: AssigneesCreateNestedOneWithoutUsersInput
  comments: CommentsCreateNestedManyWithoutUsersInput
  created_at: DateTime!
  email: String!
  id: String
  last_sign_in_at: DateTime!
  password: String!
  preferences: JSON!
  tasks: TasksCreateNestedManyWithoutUsersInput
  updated_at: DateTime!
}

input UsersCreateWithoutTasksInput {
  active: Boolean!
  assignees: AssigneesCreateNestedOneWithoutUsersInput
  comments: CommentsCreateNestedManyWithoutUsersInput
  created_at: DateTime!
  email: String!
  id: String
  last_sign_in_at: DateTime!
  notifications: NotificationsCreateNestedManyWithoutUsersInput
  password: String!
  preferences: JSON!
  updated_at: DateTime!
}

type UsersGroupBy {
  _count: UsersCountAggregate
  _max: UsersMaxAggregate
  _min: UsersMinAggregate
  active: Boolean!
  created_at: DateTime!
  email: String!
  id: String!
  last_sign_in_at: DateTime!
  password: String!
  password_digest: String!
  preferences: JSON!
  updated_at: DateTime!
}

type UsersMaxAggregate {
  active: Boolean
  created_at: DateTime
  email: String
  id: String
  last_sign_in_at: DateTime
  password: String
  password_digest: String
  updated_at: DateTime
}

input UsersMaxOrderByAggregateInput {
  active: SortOrder
  created_at: SortOrder
  email: SortOrder
  id: SortOrder
  last_sign_in_at: SortOrder
  password: SortOrder
  updated_at: SortOrder
}

type UsersMinAggregate {
  active: Boolean
  created_at: DateTime
  email: String
  id: String
  last_sign_in_at: DateTime
  password: String
  password_digest: String
  updated_at: DateTime
}

input UsersMinOrderByAggregateInput {
  active: SortOrder
  created_at: SortOrder
  email: SortOrder
  id: SortOrder
  last_sign_in_at: SortOrder
  password: SortOrder
  updated_at: SortOrder
}

input UsersOrderByWithAggregationInput {
  _count: UsersCountOrderByAggregateInput
  _max: UsersMaxOrderByAggregateInput
  _min: UsersMinOrderByAggregateInput
  active: SortOrder
  created_at: SortOrder
  email: SortOrder
  id: SortOrder
  last_sign_in_at: SortOrder
  password: SortOrder
  preferences: SortOrder
  updated_at: SortOrder
}

input UsersOrderByWithRelationInput {
  active: SortOrder
  assignees: AssigneesOrderByWithRelationInput
  comments: CommentsOrderByRelationAggregateInput
  created_at: SortOrder
  email: SortOrder
  id: SortOrder
  last_sign_in_at: SortOrder
  notifications: NotificationsOrderByRelationAggregateInput
  password: SortOrder
  preferences: SortOrder
  tasks: TasksOrderByRelationAggregateInput
  updated_at: SortOrder
}

input UsersRelationFilter {
  is: UsersWhereInput
  isNot: UsersWhereInput
}

enum UsersScalarFieldEnum {
  active
  created_at
  email
  id
  last_sign_in_at
  password
  password_digest
  preferences
  updated_at
}

input UsersScalarWhereWithAggregatesInput {
  AND: [UsersScalarWhereWithAggregatesInput!]
  NOT: [UsersScalarWhereWithAggregatesInput!]
  OR: [UsersScalarWhereWithAggregatesInput!]
  active: BoolWithAggregatesFilter
  created_at: DateTimeWithAggregatesFilter
  email: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  last_sign_in_at: DateTimeWithAggregatesFilter
  password: StringWithAggregatesFilter
  preferences: JsonWithAggregatesFilter
  updated_at: DateTimeWithAggregatesFilter
}

input UsersUpdateInput {
  active: BoolFieldUpdateOperationsInput
  assignees: AssigneesUpdateOneWithoutUsersNestedInput
  comments: CommentsUpdateManyWithoutUsersNestedInput
  created_at: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  last_sign_in_at: DateTimeFieldUpdateOperationsInput
  notifications: NotificationsUpdateManyWithoutUsersNestedInput
  password: StringFieldUpdateOperationsInput
  preferences: JSON
  tasks: TasksUpdateManyWithoutUsersNestedInput
  updated_at: DateTimeFieldUpdateOperationsInput
}

input UsersUpdateManyMutationInput {
  active: BoolFieldUpdateOperationsInput
  created_at: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  last_sign_in_at: DateTimeFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  preferences: JSON
  updated_at: DateTimeFieldUpdateOperationsInput
}

input UsersUpdateOneRequiredWithoutAssigneesNestedInput {
  connect: UsersWhereUniqueInput
  connectOrCreate: UsersCreateOrConnectWithoutAssigneesInput
  create: UsersCreateWithoutAssigneesInput
  update: UsersUpdateWithoutAssigneesInput
  upsert: UsersUpsertWithoutAssigneesInput
}

input UsersUpdateOneRequiredWithoutCommentsNestedInput {
  connect: UsersWhereUniqueInput
  connectOrCreate: UsersCreateOrConnectWithoutCommentsInput
  create: UsersCreateWithoutCommentsInput
  update: UsersUpdateWithoutCommentsInput
  upsert: UsersUpsertWithoutCommentsInput
}

input UsersUpdateOneRequiredWithoutNotificationsNestedInput {
  connect: UsersWhereUniqueInput
  connectOrCreate: UsersCreateOrConnectWithoutNotificationsInput
  create: UsersCreateWithoutNotificationsInput
  update: UsersUpdateWithoutNotificationsInput
  upsert: UsersUpsertWithoutNotificationsInput
}

input UsersUpdateOneRequiredWithoutTasksNestedInput {
  connect: UsersWhereUniqueInput
  connectOrCreate: UsersCreateOrConnectWithoutTasksInput
  create: UsersCreateWithoutTasksInput
  update: UsersUpdateWithoutTasksInput
  upsert: UsersUpsertWithoutTasksInput
}

input UsersUpdateWithoutAssigneesInput {
  active: BoolFieldUpdateOperationsInput
  comments: CommentsUpdateManyWithoutUsersNestedInput
  created_at: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  last_sign_in_at: DateTimeFieldUpdateOperationsInput
  notifications: NotificationsUpdateManyWithoutUsersNestedInput
  password: StringFieldUpdateOperationsInput
  preferences: JSON
  tasks: TasksUpdateManyWithoutUsersNestedInput
  updated_at: DateTimeFieldUpdateOperationsInput
}

input UsersUpdateWithoutCommentsInput {
  active: BoolFieldUpdateOperationsInput
  assignees: AssigneesUpdateOneWithoutUsersNestedInput
  created_at: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  last_sign_in_at: DateTimeFieldUpdateOperationsInput
  notifications: NotificationsUpdateManyWithoutUsersNestedInput
  password: StringFieldUpdateOperationsInput
  preferences: JSON
  tasks: TasksUpdateManyWithoutUsersNestedInput
  updated_at: DateTimeFieldUpdateOperationsInput
}

input UsersUpdateWithoutNotificationsInput {
  active: BoolFieldUpdateOperationsInput
  assignees: AssigneesUpdateOneWithoutUsersNestedInput
  comments: CommentsUpdateManyWithoutUsersNestedInput
  created_at: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  last_sign_in_at: DateTimeFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  preferences: JSON
  tasks: TasksUpdateManyWithoutUsersNestedInput
  updated_at: DateTimeFieldUpdateOperationsInput
}

input UsersUpdateWithoutTasksInput {
  active: BoolFieldUpdateOperationsInput
  assignees: AssigneesUpdateOneWithoutUsersNestedInput
  comments: CommentsUpdateManyWithoutUsersNestedInput
  created_at: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  last_sign_in_at: DateTimeFieldUpdateOperationsInput
  notifications: NotificationsUpdateManyWithoutUsersNestedInput
  password: StringFieldUpdateOperationsInput
  preferences: JSON
  updated_at: DateTimeFieldUpdateOperationsInput
}

input UsersUpsertWithoutAssigneesInput {
  create: UsersCreateWithoutAssigneesInput!
  update: UsersUpdateWithoutAssigneesInput!
}

input UsersUpsertWithoutCommentsInput {
  create: UsersCreateWithoutCommentsInput!
  update: UsersUpdateWithoutCommentsInput!
}

input UsersUpsertWithoutNotificationsInput {
  create: UsersCreateWithoutNotificationsInput!
  update: UsersUpdateWithoutNotificationsInput!
}

input UsersUpsertWithoutTasksInput {
  create: UsersCreateWithoutTasksInput!
  update: UsersUpdateWithoutTasksInput!
}

input UsersWhereInput {
  AND: [UsersWhereInput!]
  NOT: [UsersWhereInput!]
  OR: [UsersWhereInput!]
  active: BoolFilter
  assignees: AssigneesRelationFilter
  comments: CommentsListRelationFilter
  created_at: DateTimeFilter
  email: StringFilter
  id: StringFilter
  last_sign_in_at: DateTimeFilter
  notifications: NotificationsListRelationFilter
  password: StringFilter
  preferences: JsonFilter
  tasks: TasksListRelationFilter
  updated_at: DateTimeFilter
}

input UsersWhereUniqueInput {
  email: String
  id: String
}