"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var getPlatform_exports = {};
__export(getPlatform_exports, {
  getPlatform: () => getPlatform,
  getSSLVersion: () => getSSLVersion,
  getos: () => getos,
  parseDistro: () => parseDistro,
  parseLibSSLVersion: () => parseLibSSLVersion,
  parseOpenSSLVersion: () => parseOpenSSLVersion,
  resolveDistro: () => resolveDistro
});
module.exports = __toCommonJS(getPlatform_exports);
var import_child_process = __toESM(require("child_process"));
var import_fs = __toESM(require("fs"));
var import_os = __toESM(require("os"));
var import_ts_pattern = require("ts-pattern");
var import_util = require("util");
const readFile = (0, import_util.promisify)(import_fs.default.readFile);
const exists = (0, import_util.promisify)(import_fs.default.exists);
const exec = (0, import_util.promisify)(import_child_process.default.exec);
async function getos() {
  const platform = import_os.default.platform();
  const arch = process.arch;
  if (platform === "freebsd") {
    const version = await getFirstSuccessfulExec([`freebsd-version`]);
    if (version && version.trim().length > 0) {
      const regex = /^(\d+)\.?/;
      const match2 = regex.exec(version);
      if (match2) {
        return {
          platform: "freebsd",
          distro: `freebsd${match2[1]}`,
          arch
        };
      }
    }
  }
  if (platform !== "linux") {
    return {
      platform,
      arch
    };
  }
  const distro = await resolveDistro();
  return {
    platform: "linux",
    libssl: await getSSLVersion({ arch, distro }),
    distro,
    arch
  };
}
__name(getos, "getos");
function parseDistro(input) {
  const idRegex = /^ID="?([^"\n]*)"?$/im;
  const idLikeRegex = /^ID_LIKE="?([^"\n]*)"?$/im;
  const idMatch = idRegex.exec(input);
  const id = idMatch && idMatch[1] && idMatch[1].toLowerCase() || "";
  const idLikeMatch = idLikeRegex.exec(input);
  const idLike = idLikeMatch && idLikeMatch[1] && idLikeMatch[1].toLowerCase() || "";
  if (id === "raspbian") {
    return "arm";
  }
  if (id === "nixos") {
    return "nixos";
  }
  if (idLike.includes("centos") || idLike.includes("fedora") || idLike.includes("rhel") || id === "fedora") {
    return "rhel";
  }
  if (idLike.includes("debian") || idLike.includes("ubuntu") || id === "debian") {
    return "debian";
  }
  return;
}
__name(parseDistro, "parseDistro");
async function resolveDistro() {
  const osReleaseFile = "/etc/os-release";
  const alpineReleaseFile = "/etc/alpine-release";
  if (await exists(alpineReleaseFile)) {
    return "musl";
  } else if (await exists(osReleaseFile)) {
    return parseDistro(await readFile(osReleaseFile, "utf-8"));
  } else {
    return;
  }
}
__name(resolveDistro, "resolveDistro");
function parseOpenSSLVersion(input) {
  const match2 = /^OpenSSL\s(\d+\.\d+)\.\d+/.exec(input);
  if (match2) {
    const partialVersion = `${match2[1]}.x`;
    return sanitiseSSLVersion(partialVersion);
  }
  return void 0;
}
__name(parseOpenSSLVersion, "parseOpenSSLVersion");
function parseLibSSLVersion(input) {
  var _a;
  const match2 = /libssl\.so\.(\d)(\.\d)?/.exec(input);
  if (match2) {
    const partialVersion = `${match2[1]}${(_a = match2[2]) != null ? _a : ".0"}.x`;
    return sanitiseSSLVersion(partialVersion);
  }
  return void 0;
}
__name(parseLibSSLVersion, "parseLibSSLVersion");
function sanitiseSSLVersion(version) {
  if (isLibssl1x(version)) {
    return version;
  }
  const versionSplit = version.split(".");
  versionSplit[1] = "0";
  return versionSplit.join(".");
}
__name(sanitiseSSLVersion, "sanitiseSSLVersion");
async function getSSLVersion(args) {
  const libsslVersion = await (0, import_ts_pattern.match)(args).with({ distro: "musl" }, () => {
    return getFirstSuccessfulExec(["ls -l /lib/libssl.so.3", "ls -l /lib/libssl.so.1.1"]);
  }).otherwise(() => {
    return getFirstSuccessfulExec(["ls -l /lib64 | grep ssl", "ls -l /usr/lib64 | grep ssl"]);
  });
  if (libsslVersion) {
    const matchedVersion = parseLibSSLVersion(libsslVersion);
    if (matchedVersion) {
      return matchedVersion;
    }
  }
  const openSSLVersion = await getFirstSuccessfulExec(["openssl version -v"]);
  if (openSSLVersion) {
    const matchedVersion = parseOpenSSLVersion(openSSLVersion);
    if (matchedVersion) {
      return matchedVersion;
    }
  }
  return void 0;
}
__name(getSSLVersion, "getSSLVersion");
async function getPlatform() {
  const { platform, libssl, distro, arch } = await getos();
  if (platform === "darwin" && arch === "arm64") {
    return "darwin-arm64";
  }
  if (platform === "darwin") {
    return "darwin";
  }
  if (platform === "win32") {
    return "windows";
  }
  if (platform === "freebsd") {
    return distro;
  }
  if (platform === "openbsd") {
    return "openbsd";
  }
  if (platform === "netbsd") {
    return "netbsd";
  }
  if (platform === "linux" && distro === "nixos") {
    return "linux-nixos";
  }
  if (platform === "linux" && arch === "arm64") {
    return `linux-arm64-openssl-${libssl}`;
  }
  if (platform === "linux" && arch === "arm") {
    return `linux-arm-openssl-${libssl}`;
  }
  if (platform === "linux" && distro === "musl") {
    const base = "linux-musl";
    if (!libssl) {
      return base;
    }
    if (isLibssl1x(libssl)) {
      return base;
    } else {
      return `${base}-openssl-${libssl}`;
    }
  }
  if (platform === "linux" && distro && libssl) {
    return distro + "-openssl-" + libssl;
  }
  if (libssl) {
    return "debian-openssl-" + libssl;
  }
  if (distro) {
    return distro + "-openssl-1.1.x";
  }
  return "debian-openssl-1.1.x";
}
__name(getPlatform, "getPlatform");
async function discardError(runPromise) {
  try {
    return await runPromise();
  } catch (e) {
    return void 0;
  }
}
__name(discardError, "discardError");
function getFirstSuccessfulExec(commands) {
  return discardError(async () => {
    const results = await Promise.allSettled(commands.map((cmd) => exec(cmd)));
    const { value } = results.find(({ status }) => status === "fulfilled");
    return String(value.stdout);
  });
}
__name(getFirstSuccessfulExec, "getFirstSuccessfulExec");
function isLibssl1x(libssl) {
  return libssl.startsWith("1.");
}
__name(isLibssl1x, "isLibssl1x");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  getPlatform,
  getSSLVersion,
  getos,
  parseDistro,
  parseLibSSLVersion,
  parseOpenSSLVersion,
  resolveDistro
});
