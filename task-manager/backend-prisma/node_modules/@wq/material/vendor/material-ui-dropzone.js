import PropTypes from 'prop-types';
import {
    useState,
    useCallback,
    useEffect,
    createElement,
    Fragment
} from 'react';
import Grid from '@material-ui/core/Grid';
import Snackbar from '@material-ui/core/Snackbar';
import Typography from '@material-ui/core/Typography';
import makeStyles$1 from '@material-ui/core/styles/makeStyles';
import AttachFileIcon from '@material-ui/icons/AttachFile';
import CloudUploadIcon from '@material-ui/icons/CloudUpload';
import clsx from 'clsx';
import Dropzone from 'react-dropzone';
import Chip from '@material-ui/core/Chip';
import GridList from '@material-ui/core/GridList';
import GridListTile from '@material-ui/core/GridListTile';
import GridListTileBar from '@material-ui/core/GridListTileBar';
import IconButton from '@material-ui/core/IconButton';
import { useTheme, makeStyles } from '@material-ui/core/styles';
import DeleteIcon from '@material-ui/icons/Delete';
import matchMediaQuery from '@material-ui/core/useMediaQuery';
import SnackbarContent from '@material-ui/core/SnackbarContent';
import CheckCircleIcon from '@material-ui/icons/CheckCircle';
import CloseIcon from '@material-ui/icons/Close';
import ErrorIcon from '@material-ui/icons/Error';
import InfoIcon from '@material-ui/icons/Info';
import WarningIcon from '@material-ui/icons/Warning';
import Button from '@material-ui/core/Button';
import Dialog from '@material-ui/core/Dialog';
import DialogActions from '@material-ui/core/DialogActions';
import DialogContent from '@material-ui/core/DialogContent';
import DialogTitle from '@material-ui/core/DialogTitle';

function isImage(file) {
    if (file.type.split('/')[0] === 'image') {
        return true;
    }

    return false;
}

function convertBytesToMbsOrKbs(filesize) {
    let size = ''; // I know, not technically correct...

    if (filesize >= 1000000) {
        size = `${filesize / 1000000} megabytes`;
    } else if (filesize >= 1000) {
        size = `${filesize / 1000} kilobytes`;
    } else {
        size = `${filesize} bytes`;
    }

    return size;
}

async function createFileFromUrl(url) {
    const response = await fetch(url);
    const data = await response.blob();
    const metadata = {
        type: data.type
    };
    const filename = url.replace(/\?.+/, '').split('/').pop();
    return new File([data], filename, metadata);
}

function readFile(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();

        reader.onload = event => {
            var _event$target;

            resolve(
                event === null || event === void 0
                    ? void 0
                    : (_event$target = event.target) === null ||
                      _event$target === void 0
                    ? void 0
                    : _event$target.result
            );
        };

        reader.onerror = event => {
            reader.abort();
            reject(event);
        };

        reader.readAsDataURL(file);
    });
}
/**
 * holds files in its state and provides some handler methods to add and remove from that state
 */

const useFiles = ({
    onChange,
    clearOnUnmount,
    initialFiles,
    filesLimit,
    onDelete
}) => {
    const [fileObjects, setFileObjects] = useState([]);
    const loadInitialFiles = useCallback(async () => {
        try {
            const fileObjs = await Promise.all(
                initialFiles.map(async initialFile => {
                    let file;

                    if (typeof initialFile === 'string') {
                        file = await createFileFromUrl(initialFile);
                    } else {
                        file = initialFile;
                    }

                    const data = await readFile(file);
                    return {
                        file,
                        data
                    };
                })
            );
            setFileObjects(prev => [...prev, ...fileObjs]);
        } catch (err) {
            console.log(err);
        }
    }, [initialFiles]);
    const handleAddFiles = useCallback(
        newFileObjects => {
            // Update component state
            setFileObjects(prev => {
                if (filesLimit <= 1) {
                    return [newFileObjects[0]];
                }

                return [...prev, ...newFileObjects];
            });
        },
        [filesLimit]
    );
    const handleDeleteFile = useCallback(
        (removedFileObj, removedFileObjIdx) => {
            // Calculate remaining fileObjects array
            const remainingFileObjs = fileObjects.filter((fileObject, i) => {
                return i !== removedFileObjIdx;
            }); // Notify removed file

            if (onDelete) {
                onDelete(removedFileObj.file);
            } // Update local state

            setFileObjects(remainingFileObjs);
        },
        [onDelete, fileObjects]
    );

    const handleResetFiles = () => setFileObjects([]); // When the fileObjects change, fire the onChange method if it's defined

    useEffect(() => {
        if (onChange) {
            onChange(fileObjects.map(fileObject => fileObject.file));
        }
    }, [fileObjects, onChange]); // Initialize the files when the hook is loaded

    useEffect(() => {
        loadInitialFiles();
        return () => {
            if (clearOnUnmount) {
                setFileObjects([]);
            }
        };
    }, [clearOnUnmount, loadInitialFiles]);
    return {
        handleAddFiles,
        handleDeleteFile,
        handleResetFiles,
        fileObjects
    };
};
/**
 * Holds state required to utilize the snackbar and provides handlers to send messages via the snackbar
 */

const useSnackbar = onAlert => {
    const [state, setState] = useState({
        open: false,
        message: '',
        variant: 'success'
    });
    const sendMessage = useCallback(
        (message, variant) => {
            setState({
                open: true,
                message,
                variant
            });

            if (onAlert) {
                onAlert(message, variant);
            }
        },
        [onAlert]
    );
    const handleCloseSnackbar = useCallback(() => {
        setState(prev => ({ ...prev, open: false }));
    }, []);
    return {
        handleCloseSnackbar,
        sendMessage,
        snackbarMessage: state.message,
        snackbarVariant: state.variant,
        snackbarOpen: state.open
    };
};
/**
 * Returns xs,sm,md,lg or xl depending on the screenSize
 * @see https://material-ui.com/components/use-media-query/#migrating-from-withwidth
 */

const useWidth = () => {
    const theme = useTheme();
    const keys = [...theme.breakpoints.keys].reverse();
    return (
        keys.reduce((output, key) => {
            const matches = matchMediaQuery(theme.breakpoints.up(key));
            return !output && matches ? key : output;
        }, null) || 'xs'
    );
};
/**
 * Calculates the number of columns to use in the preview based on a function passed in
 * numberOfColumns is a state variable which will update every time the width of the
 * screen changes
 */

const useColumns = (getCols, filesLimit, numberOfFileObjects) => {
    const [numberOfColumns, setCols] = useState(1);
    const width = useWidth();
    useEffect(() => {
        const cols = getCols(width, filesLimit, numberOfFileObjects);
        setCols(cols);
    }, [filesLimit, getCols, numberOfFileObjects, width]);
    return numberOfColumns;
};

const useStyles = makeStyles(
    ({ spacing }) => ({
        root: {
            alignItems: 'center',
            position: 'absolute',
            width: '100%',
            height: '100%',
            margin: 0,
            backgroundColor: 'rgba(255,255,255,0.87)'
        },
        icon: {
            color: 'rgba(255, 255, 255, 0.54)'
        },
        iconWrapper: {
            height: '100%',
            backgroundColor: '#f2f2f2'
        },
        fileIcon: {
            flexGrow: 1,
            height: '50%',
            marginTop: spacing(3)
        },
        fileIconBottom: {
            marginTop: spacing(9)
        }
    }),
    {
        name: 'MuiDropzonePreviewList'
    }
);

const PreviewList = ({
    fileObjects,
    filesLimit,
    getCols,
    handleRemove,
    showFileNames,
    useChipsForPreview,
    previewChipProps,
    previewGridClasses,
    previewGridProps,
    previewType,
    getPreviewIcon,
    handlePreviewClick
}) => {
    const classes = useStyles();
    const cols = useColumns(getCols, filesLimit, fileObjects.length);
    const previewInside = previewType === 'inside';

    if (useChipsForPreview) {
        return fileObjects.map((fileObject, i) =>
            /*#__PURE__*/ createElement(
                'div',
                {
                    key: i
                },
                /*#__PURE__*/ createElement(Chip, {
                    variant: 'outlined',
                    ...previewChipProps,
                    label: fileObject.file.name,
                    onDelete: handleRemove(i)
                })
            )
        );
    }

    return /*#__PURE__*/ createElement(
        GridList,
        {
            cols: cols,
            className: clsx(
                {
                    [classes.root]: previewInside
                },
                previewGridClasses.container
            ),
            ...(previewGridProps === null || previewGridProps === void 0
                ? void 0
                : previewGridProps.gridList)
        },
        fileObjects.map((fileObject, i) => {
            var _fileObject$file,
                _fileObject$file$name,
                _fileObject$file2,
                _previewGridProps$gri;

            const fileTitle =
                showFileNames &&
                ((_fileObject$file = fileObject.file) === null ||
                _fileObject$file === void 0
                    ? void 0
                    : _fileObject$file.name);
            const isImage$1 = isImage(fileObject.file);
            return /*#__PURE__*/ createElement(
                GridListTile,
                {
                    key: `${
                        (_fileObject$file$name =
                            (_fileObject$file2 = fileObject.file) === null ||
                            _fileObject$file2 === void 0
                                ? void 0
                                : _fileObject$file2.name) !== null &&
                        _fileObject$file$name !== void 0
                            ? _fileObject$file$name
                            : 'file'
                    }-${i}`,
                    className: clsx(previewGridClasses.gridListTile, {
                        [classes.iconWrapper]: !isImage$1
                    }),
                    onClick: handlePreviewClick(i),
                    onKeyDown: handlePreviewClick(i),
                    ...(previewGridProps === null || previewGridProps === void 0
                        ? void 0
                        : previewGridProps.gridListTitle)
                },
                getPreviewIcon(
                    fileObject,
                    classes,
                    isImage$1,
                    (previewGridProps === null || previewGridProps === void 0
                        ? void 0
                        : (_previewGridProps$gri =
                              previewGridProps.gridListTitleBar) === null ||
                          _previewGridProps$gri === void 0
                        ? void 0
                        : _previewGridProps$gri.titlePosition) === 'top'
                ),
                /*#__PURE__*/ createElement(GridListTileBar, {
                    title: fileTitle,
                    actionIcon: /*#__PURE__*/ createElement(
                        IconButton,
                        {
                            onClick: handleRemove(i),
                            'aria-label': 'Delete',
                            className: clsx(
                                previewGridClasses.removeIconButton,
                                classes.icon
                            )
                        },
                        /*#__PURE__*/ createElement(DeleteIcon, null)
                    ),
                    ...(previewGridProps === null || previewGridProps === void 0
                        ? void 0
                        : previewGridProps.gridListTitleBar)
                })
            );
        })
    );
};

PreviewList.propTypes = {
    fileObjects: PropTypes.arrayOf(PropTypes.object).isRequired,
    filesLimit: PropTypes.number.isRequired,
    getCols: PropTypes.func.isRequired,
    getPreviewIcon: PropTypes.func.isRequired,
    handleRemove: PropTypes.func.isRequired,
    handlePreviewClick: PropTypes.func.isRequired,
    previewChipProps: PropTypes.object,
    previewGridClasses: PropTypes.object,
    previewGridProps: PropTypes.object,
    previewType: PropTypes.string.isRequired,
    showFileNames: PropTypes.bool,
    useChipsForPreview: PropTypes.bool
};
const variantIcon = {
    success: CheckCircleIcon,
    warning: WarningIcon,
    error: ErrorIcon,
    info: InfoIcon
};
const useStyles$1 = makeStyles(
    theme => ({
        success: {
            backgroundColor: theme.palette.success.main
        },
        error: {
            backgroundColor: theme.palette.error.main
        },
        info: {
            backgroundColor: theme.palette.info.main
        },
        warning: {
            backgroundColor: theme.palette.warning.main
        },
        message: {
            display: 'flex',
            alignItems: 'center',
            '& > svg': {
                marginRight: theme.spacing(1)
            }
        },
        icon: {
            fontSize: 20,
            opacity: 0.9
        },
        closeButton: {}
    }),
    {
        name: 'MuiDropzoneSnackbar'
    }
);

function SnackbarContentWrapper({
    className,
    message,
    onClose,
    variant,
    ...other
}) {
    const classes = useStyles$1();
    const Icon = variantIcon[variant];
    return /*#__PURE__*/ createElement(SnackbarContent, {
        className: clsx(classes[variant], className),
        'aria-describedby': 'client-snackbar',
        message: /*#__PURE__*/ createElement(
            'span',
            {
                id: 'client-snackbar',
                className: classes.message
            },
            /*#__PURE__*/ createElement(Icon, {
                className: classes.icon
            }),
            message
        ),
        action: [
            /*#__PURE__*/ createElement(
                IconButton,
                {
                    key: 'close',
                    'aria-label': 'Close',
                    color: 'inherit',
                    className: classes.closeButton,
                    onClick: onClose
                },
                /*#__PURE__*/ createElement(CloseIcon, {
                    className: classes.icon
                })
            )
        ],
        ...other
    });
}

SnackbarContentWrapper.propTypes = {
    className: PropTypes.string,
    message: PropTypes.node,
    onClose: PropTypes.func,
    variant: PropTypes.oneOf(['success', 'warning', 'error', 'info']).isRequired
};
const useStyles$2 = makeStyles$1(
    ({ spacing, palette, shape }) => ({
        '@keyframes progress': {
            '0%': {
                backgroundPosition: '0 0'
            },
            '100%': {
                backgroundPosition: '-70px 0'
            }
        },
        root: {
            display: 'flex',
            position: 'relative',
            width: '100%',
            minHeight: '250px',
            backgroundColor: palette.background.paper,
            border: 'dashed',
            borderColor: palette.divider,
            borderRadius: shape.borderRadius,
            boxSizing: 'border-box',
            cursor: 'pointer',
            overflow: 'hidden',
            flexDirection: 'column',
            justifyContent: 'center'
        },
        active: {
            animation: '$progress 2s linear infinite !important',
            backgroundImage: `repeating-linear-gradient(-45deg,
            ${palette.background.paper},
            ${palette.background.paper} 25px,
            ${palette.divider} 25px,
            ${palette.divider} 50px)`,
            backgroundSize: '150% 100%',
            border: 'solid',
            borderColor: palette.primary.light
        },
        invalid: {
            backgroundImage: `repeating-linear-gradient(-45deg,
            ${palette.error.light},
            ${palette.error.light} 25px,
            ${palette.error.dark} 25px,
            ${palette.error.dark} 50px)`,
            borderColor: palette.error.main
        },
        textContainer: {
            display: 'flex'
        },
        text: {
            marginBottom: spacing(3),
            marginTop: spacing(3)
        },
        icon: {
            width: 51,
            height: 51,
            color: palette.text.primary
        }
    }),
    {
        name: 'MuiDropzoneArea'
    }
);

const shouldShowAlert = (enabledAlerts, alertVariant) => {
    if (!Array.isArray(enabledAlerts)) {
        return true;
    }

    return enabledAlerts.includes(alertVariant);
};

const defaultGetCols = (width, filesLimit) => {
    const returnBelowLimit = number => {
        if (number < filesLimit) {
            return number;
        }

        return filesLimit;
    };

    switch (width) {
        case 'xs':
            return returnBelowLimit(1);

        case 'sm':
            return returnBelowLimit(2);

        case 'md':
            return returnBelowLimit(3);

        case 'lg':
            return returnBelowLimit(4);

        case 'xl':
            return returnBelowLimit(5);

        default:
            return returnBelowLimit(3);
    }
};

const defaultSnackbarAnchorOrigin = {
    horizontal: 'left',
    vertical: 'bottom'
};

const defaultGetPreviewIcon = (fileObject, classes, isImage, titleBarTop) => {
    if (isImage) {
        return /*#__PURE__*/ createElement('img', {
            alt: '',
            className: classes.image,
            src: fileObject.data
        });
    }

    return /*#__PURE__*/ createElement(
        Grid,
        {
            container: true,
            className: classes.iconWrapper,
            justify: 'center'
        },
        /*#__PURE__*/ createElement(AttachFileIcon, {
            className: clsx(classes.fileIcon, {
                [classes.fileIconBottom]: titleBarTop
            })
        })
    );
};
/**
 * This components creates a Material-UI Dropzone, with previews and snackbar notifications.
 */

const DropzoneAreaBase = ({
    fileObjects,
    filesLimit,
    getFileAddedMessage,
    getFileLimitExceedMessage,
    getFileRemovedMessage,
    getDropRejectMessage,
    onAdd,
    onAlert,
    onDrop,
    onDropRejected,
    onDelete,
    onPreviewClick,
    acceptedFiles,
    alertSnackbarProps,
    disableRejectionFeedback,
    dropzoneClass,
    dropzoneParagraphClass,
    dropzoneProps,
    dropzoneText,
    getCols,
    getPreviewIcon,
    Icon,
    inputProps,
    maxFileSize,
    previewChipProps,
    previewGridClasses,
    previewGridProps,
    previewText,
    previewType,
    showAlerts,
    showFileNames,
    useChipsForPreview
}) => {
    const classes = useStyles$2();
    const {
        handleCloseSnackbar,
        sendMessage,
        snackbarMessage,
        snackbarOpen,
        snackbarVariant
    } = useSnackbar(onAlert);
    const handleDropAccepted = useCallback(
        async (droppedFiles, evt) => {
            if (
                filesLimit > 1 &&
                fileObjects.length + droppedFiles.length > filesLimit
            ) {
                const message = getFileLimitExceedMessage(filesLimit);
                sendMessage(message, 'error');
                return;
            } // Notify Drop event

            if (onDrop) {
                onDrop(droppedFiles, evt);
            } // Retrieve fileObjects data

            const fileObjs = await Promise.all(
                droppedFiles.map(async file => {
                    const data = await readFile(file);
                    return {
                        file,
                        data
                    };
                })
            ); // Notify added files

            if (onAdd) {
                onAdd(fileObjs);
            }

            const successMessage = fileObjs.reduce(
                (msg, fileObj) => msg + getFileAddedMessage(fileObj.file.name),
                ''
            );
            sendMessage(successMessage, 'success');
        },
        [
            filesLimit,
            fileObjects.length,
            onDrop,
            onAdd,
            sendMessage,
            getFileLimitExceedMessage,
            getFileAddedMessage
        ]
    );
    const handleDropRejected = useCallback(
        (rejectedFiles, evt) => {
            let message = '';
            rejectedFiles.forEach(rejectedFile => {
                message = getDropRejectMessage(
                    rejectedFile,
                    acceptedFiles,
                    maxFileSize
                );
            });

            if (onDropRejected) {
                onDropRejected(rejectedFiles, evt);
            }

            sendMessage(message, 'error');
        },
        [
            acceptedFiles,
            getDropRejectMessage,
            maxFileSize,
            onDropRejected,
            sendMessage
        ]
    );
    const handleRemove = useCallback(
        fileIndex => event => {
            event.stopPropagation(); // Find removed fileObject

            const removedFileObj = fileObjects[fileIndex]; // Notify removed file

            if (onDelete) {
                onDelete(removedFileObj, fileIndex);
            }

            const message = getFileRemovedMessage(removedFileObj.file.name);
            sendMessage(message, 'info');
        },
        [fileObjects, onDelete, getFileRemovedMessage, sendMessage]
    );
    const handlePreviewClick = useCallback(
        fileIndex => event => {
            event.stopPropagation(); // Find previewed fileObject

            const previewedFileObj = fileObjects[fileIndex];
            onPreviewClick(previewedFileObj, fileIndex);
        },
        [fileObjects, onPreviewClick]
    );
    const acceptFiles =
        acceptedFiles === null || acceptedFiles === void 0
            ? void 0
            : acceptedFiles.join(',');
    const isMultiple = filesLimit > 1;
    const someFiles = fileObjects.length > 0;
    const alertsEnabled =
        (typeof showAlerts === 'boolean' && showAlerts) ||
        Array.isArray(showAlerts);
    const isAlertOpen =
        snackbarOpen && shouldShowAlert(showAlerts, snackbarVariant);
    return /*#__PURE__*/ createElement(
        Fragment,
        null,
        /*#__PURE__*/ createElement(
            Dropzone,
            {
                ...dropzoneProps,
                accept: acceptFiles,
                onDropAccepted: handleDropAccepted,
                onDropRejected: handleDropRejected,
                maxSize: maxFileSize,
                multiple: isMultiple
            },
            ({ getRootProps, getInputProps, isDragActive, isDragReject }) =>
                /*#__PURE__*/ createElement(
                    'div',
                    {
                        ...getRootProps({
                            className: clsx(
                                classes.root,
                                dropzoneClass,
                                isDragActive && classes.active,
                                !disableRejectionFeedback &&
                                    isDragReject &&
                                    classes.invalid
                            )
                        })
                    },
                    /*#__PURE__*/ createElement('input', {
                        ...getInputProps(inputProps)
                    }),
                    /*#__PURE__*/ createElement(
                        Grid,
                        {
                            container: true,
                            className: classes.textContainer,
                            direction: 'column',
                            justify: 'center',
                            alignItems: 'center'
                        },
                        /*#__PURE__*/ createElement(
                            Typography,
                            {
                                variant: 'h5',
                                component: 'p',
                                className: clsx(
                                    classes.text,
                                    dropzoneParagraphClass
                                )
                            },
                            dropzoneText
                        ),
                        Icon
                            ? /*#__PURE__*/ createElement(Icon, {
                                  className: classes.icon
                              })
                            : /*#__PURE__*/ createElement(CloudUploadIcon, {
                                  className: classes.icon
                              })
                    ),
                    someFiles && previewType === 'inside'
                        ? /*#__PURE__*/ createElement(PreviewList, {
                              fileObjects: fileObjects,
                              filesLimit: filesLimit,
                              getCols: getCols,
                              handleRemove: handleRemove,
                              getPreviewIcon: getPreviewIcon,
                              showFileNames: showFileNames,
                              useChipsForPreview: useChipsForPreview,
                              previewChipProps: previewChipProps,
                              previewGridClasses: previewGridClasses,
                              previewGridProps: previewGridProps,
                              previewType: previewType,
                              handlePreviewClick: handlePreviewClick
                          })
                        : null
                )
        ),
        someFiles && previewType === 'below'
            ? /*#__PURE__*/ createElement(
                  Fragment,
                  null,
                  /*#__PURE__*/ createElement(
                      Typography,
                      {
                          variant: 'subtitle1',
                          component: 'span'
                      },
                      previewText
                  ),
                  /*#__PURE__*/ createElement(PreviewList, {
                      fileObjects: fileObjects,
                      filesLimit: filesLimit,
                      getCols: getCols,
                      handleRemove: handleRemove,
                      getPreviewIcon: getPreviewIcon,
                      showFileNames: showFileNames,
                      useChipsForPreview: useChipsForPreview,
                      previewChipProps: previewChipProps,
                      previewGridClasses: previewGridClasses,
                      previewGridProps: previewGridProps,
                      previewType: previewType,
                      handlePreviewClick: handlePreviewClick
                  })
              )
            : null,
        alertsEnabled
            ? /*#__PURE__*/ createElement(
                  Snackbar,
                  {
                      anchorOrigin: defaultSnackbarAnchorOrigin,
                      autoHideDuration: 6000,
                      ...alertSnackbarProps,
                      open: isAlertOpen,
                      onClose: handleCloseSnackbar
                  },
                  /*#__PURE__*/ createElement(SnackbarContentWrapper, {
                      onClose: handleCloseSnackbar,
                      variant: snackbarVariant,
                      message: snackbarMessage
                  })
              )
            : null
    );
};

DropzoneAreaBase.defaultProps = {
    acceptedFiles: [],
    filesLimit: 3,
    fileObjects: [],
    maxFileSize: 3000000,
    dropzoneText: 'Drag and drop a file here or click',
    previewText: 'Preview:',
    previewType: 'inside',
    disableRejectionFeedback: false,
    showFileNames: true,
    useChipsForPreview: false,
    previewChipProps: {},
    previewGridClasses: {},
    previewGridProps: {},
    showAlerts: true,
    alertSnackbarProps: {
        anchorOrigin: {
            horizontal: 'left',
            vertical: 'bottom'
        },
        autoHideDuration: 6000
    },
    getCols: defaultGetCols,
    getFileLimitExceedMessage: filesLimit =>
        `Maximum allowed number of files exceeded. Only ${filesLimit} allowed`,
    getFileAddedMessage: fileName => `File ${fileName} successfully added.`,
    getPreviewIcon: defaultGetPreviewIcon,
    getFileRemovedMessage: fileName => `File ${fileName} removed.`,
    getDropRejectMessage: (rejectedFile, acceptedFiles, maxFileSize) => {
        let message = `File ${rejectedFile.name} was rejected. `;

        if (!acceptedFiles.includes(rejectedFile.type)) {
            message += 'File type not supported. ';
        }

        if (rejectedFile.size > maxFileSize) {
            message += `File is too big. Size limit is ${convertBytesToMbsOrKbs(
                maxFileSize
            )}. `;
        }

        return message;
    },
    onPreviewClick: () => {}
};
const FileObjectShape = PropTypes.shape({
    file: PropTypes.object,
    data: PropTypes.any
});
DropzoneAreaBase.propTypes = {
    /** A list of file types to accept.
     * @see See [here](https://react-dropzone.js.org/#section-accepting-specific-file-types) for more details.
     */
    acceptedFiles: PropTypes.arrayOf(PropTypes.string),

    /** Maximum number of files that can be loaded into the dropzone. */
    filesLimit: PropTypes.number,

    /** Icon to be displayed inside the dropzone area. */
    Icon: PropTypes.elementType,

    /** Currently loaded files. */
    fileObjects: PropTypes.arrayOf(FileObjectShape),

    /** Maximum file size (in bytes) that the dropzone will accept. */
    maxFileSize: PropTypes.number,

    /** Text inside the dropzone. */
    dropzoneText: PropTypes.string,

    /** Custom CSS class name for dropzone container. */
    dropzoneClass: PropTypes.string,

    /** Custom CSS class name for text inside the container. */
    dropzoneParagraphClass: PropTypes.string,

    /** Disable feedback effect when dropping rejected files. */
    disableRejectionFeedback: PropTypes.bool,

    /** Shows file name under the dropzone image. */
    showFileNames: PropTypes.bool,

    /** Uses deletable Material-UI Chip components to display file names. */
    useChipsForPreview: PropTypes.bool,

    /**
     * Props to pass to the Material-UI Chip components.<br/>Requires `useChipsForPreview` prop to be `true`.
     *
     * @see See [Material-UI Chip](https://material-ui.com/api/chip/#props) for available values.
     */
    previewChipProps: PropTypes.object,

    /**
     * Custom CSS classNames for preview Grid components.<br/>
     * Should be in the form {container: string, item: string, image: string}.
     */
    previewGridClasses: PropTypes.object,

    /**
     * Props to pass to the Material-UI Grid components.<br/>
     * Should be in the form {container: GridProps, item: GridProps}.
     *
     * @see See [Material-UI Grid](https://material-ui.com/api/grid/#props) for available GridProps values.
     */
    previewGridProps: PropTypes.object,

    /** The label for the file preview section. */
    previewText: PropTypes.string,

    /** Determines whether previews are shown inside the dropzone area, below, or not at all. Acceptable values are 'inside', 'below', 'none'. */
    previewType: PropTypes.oneOf(['inside', 'below', 'none']),

    /**
     * Shows styled Material-UI Snackbar when files are dropped, deleted or rejected.
     *
     * - can be a boolean ("global" `true` or `false` for all alerts).
     * - can be an array, with values 'error', 'info', 'success' to select to view only certain alerts:
     *  - showAlerts={['error']} for only errors.
     *  - showAlerts={['error', 'info']} for both errors and info.
     *  - showAlerts={['error', 'success', 'info']} is same as showAlerts={true}.
     *  - showAlerts={[]} is same as showAlerts={false}.
     */
    showAlerts: PropTypes.oneOfType([
        PropTypes.bool,
        PropTypes.arrayOf(PropTypes.oneOf(['error', 'success', 'info']))
    ]),

    /**
     * Props to pass to the Material-UI Snackbar components.<br/>Requires `showAlerts` prop to be `true`.
     *
     * @see See [Material-UI Snackbar](https://material-ui.com/api/snackbar/#props) for available values.
     */
    alertSnackbarProps: PropTypes.object,

    /**
     * Props to pass to the Dropzone component.
     *
     * @see See [Dropzone props](https://react-dropzone.js.org/#src) for available values.
     */
    dropzoneProps: PropTypes.object,

    /**
     * Attributes applied to the input element.
     *
     * @see See [MDN Input File attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file#Additional_attributes) for available values.
     */
    inputProps: PropTypes.object,

    /**
     * A function which determines which the number of columns to display in the preview list
     *
     * *Default*: Returns a sensible number of columns depending on the screen size (i.e. xs=1, sm=2, md=3, lg=4, xl=5) without exceeding the filesLimit (e.g. There would be no point displaying 4 columns if the filesLimit is 3)
     *
     * @param {string} width Width prop from useWidth, this will be one of ['xs','sm','md','lg','xl'] depending on the current screen size
     * @param {number} filesLimit The `filesLimit` prop
     * @param {number} currentNumberOfFiles The number of files in the `state.fileObjects`
     */
    getCols: PropTypes.func,

    /**
     * Get alert message to display when files limit is exceed.
     *
     * *Default*: "Maximum allowed number of files exceeded. Only ${filesLimit} allowed"
     *
     * @param {number} filesLimit The `filesLimit` currently set for the component.
     */
    getFileLimitExceedMessage: PropTypes.func,

    /**
     * Get alert message to display when a new file is added.
     *
     * *Default*: "File ${fileName} successfully added."
     *
     * @param {string} fileName The newly added file name.
     */
    getFileAddedMessage: PropTypes.func,

    /**
     * Get alert message to display when a file is removed.
     *
     * *Default*: "File ${fileName} removed."
     *
     * @param {string} fileName The name of the removed file.
     */
    getFileRemovedMessage: PropTypes.func,

    /**
     * Get alert message to display when a file is rejected onDrop.
     *
     * *Default*: "File ${rejectedFile.name} was rejected."
     *
     * @param {Object} rejectedFile The file that got rejected
     * @param {string[]} acceptedFiles The `acceptedFiles` prop currently set for the component
     * @param {number} maxFileSize The `maxFileSize` prop currently set for the component
     */
    getDropRejectMessage: PropTypes.func,

    /**
     * A function which determines which icon to display for a file preview.
     *
     * *Default*: If its an image then displays a preview the image, otherwise it will display an attachment icon
     *
     * @param {FileObject} objectFile The file which the preview will belong to
     * @param {Object} classes The classes for the file preview icon, in the default case we use the 'image' className.
     */
    getPreviewIcon: PropTypes.func,

    /**
     * Fired when new files are added to dropzone.
     *
     * @param {FileObject[]} newFiles The new files added to the dropzone.
     */
    onAdd: PropTypes.func,

    /**
     * Fired when an alert is triggered.
     *
     * @param {string} message Alert message.
     * @param {string} variant One of "error", "info", "success".
     */
    onAlert: PropTypes.func,

    /**
     * Fired when a file is deleted from the previews panel.
     *
     * @param {FileObject} deletedFileObject The file that was removed.
     * @param {number} index The index of the removed file object.
     */
    onDelete: PropTypes.func,

    /**
     * Fired when the user drops files into the dropzone.
     *
     * @param {File[]} droppedFiles All the files dropped into the dropzone.
     * @param {Event} event The react-dropzone drop event.
     */
    onDrop: PropTypes.func,

    /**
     * Fired when a file is rejected because of wrong file type, size or goes beyond the filesLimit.
     *
     * @param {File[]} rejectedFiles All the rejected files.
     * @param {Event} event The react-dropzone drop event.
     */
    onDropRejected: PropTypes.func,

    /**
     * Fired when the user click que preview icon in the image. If this props was not informed, the preview icon doesn't appears.
     *
     * @param {File} clickedFile File was clicked.
     * @param {number} index The index of clicked file object.
     */
    onPreviewClick: PropTypes.func
};
/**
 * This components creates an uncontrolled Material-UI Dropzone, with previews and snackbar notifications.
 *
 * It supports all props of `DropzoneAreaBase` but keeps the files state internally.
 *
 * **Note** To listen to file changes use `onChange` event handler and notice that `onDelete` returns a `File` instance instead of `FileObject`.
 */

const DropzoneArea = ({
    clearOnUnmount,
    initialFiles,
    onChange,
    onDelete,
    filesLimit,
    ...dropzoneAreaBaseProps
}) => {
    const { handleDeleteFile, handleAddFiles, fileObjects } = useFiles({
        onChange,
        clearOnUnmount,
        initialFiles,
        filesLimit,
        onDelete
    });
    return /*#__PURE__*/ createElement(DropzoneAreaBase, {
        ...dropzoneAreaBaseProps,
        fileObjects: fileObjects,
        onAdd: handleAddFiles,
        onDelete: handleDeleteFile
    });
};

DropzoneArea.defaultProps = {
    clearOnUnmount: true,
    filesLimit: 3,
    initialFiles: []
};
DropzoneArea.propTypes = {
    ...DropzoneAreaBase.propTypes,

    /** Clear uploaded files when component is unmounted. */
    clearOnUnmount: PropTypes.bool,

    /** List containing File objects or URL strings.<br/>
     * **Note:** Please take care of CORS.
     */
    initialFiles: PropTypes.arrayOf(
        PropTypes.oneOfType([PropTypes.string, PropTypes.any])
    ),

    /** Maximum number of files that can be loaded into the dropzone. */
    filesLimit: PropTypes.number,

    /**
     * Fired when the files inside dropzone change.
     *
     * @param {File[]} loadedFiles All the files currently loaded into the dropzone.
     */
    onChange: PropTypes.func,

    /**
     * Fired when a file is deleted from the previews panel.
     *
     * @param {File} deletedFile The file that was removed.
     */
    onDelete: PropTypes.func
};
/**
 * This component provides the DropzoneArea inside of a Material-UI Dialog.
 *
 * It supports all the Props and Methods from `DropzoneAreaBase`.
 */

const DropzoneDialogBase = ({
    cancelButtonText,
    dialogProps,
    dialogTitle,
    fullWidth,
    maxWidth,
    onClose,
    onSave,
    open,
    submitButtonText,
    ...dropzoneAreaProps
}) => {
    // Submit button state
    const submitDisabled = dropzoneAreaProps.fileObjects.length === 0;
    return /*#__PURE__*/ createElement(
        Dialog,
        {
            cancelButtonText: cancelButtonText,
            dialogProps: dialogProps,
            dialogTitle: dialogTitle,
            maxWidth: maxWidth,
            onClose: onClose,
            onSave: onSave,
            open: open,
            fullWidth: fullWidth,
            fileObjects: dropzoneAreaProps.fileObjects
        },
        /*#__PURE__*/ createElement(DialogTitle, null, dialogTitle),
        /*#__PURE__*/ createElement(
            DialogContent,
            null,
            /*#__PURE__*/ createElement(DropzoneAreaBase, {
                ...dropzoneAreaProps
            })
        ),
        /*#__PURE__*/ createElement(
            DialogActions,
            null,
            /*#__PURE__*/ createElement(
                Button,
                {
                    color: 'primary',
                    onClick: onClose
                },
                cancelButtonText
            ),
            /*#__PURE__*/ createElement(
                Button,
                {
                    color: 'primary',
                    disabled: submitDisabled,
                    onClick: onSave
                },
                submitButtonText
            )
        )
    );
};

DropzoneDialogBase.defaultProps = {
    open: false,
    dialogTitle: 'Upload file',
    dialogProps: {},
    fullWidth: true,
    maxWidth: 'sm',
    cancelButtonText: 'Cancel',
    submitButtonText: 'Submit',
    showPreviews: true,
    showPreviewsInDropzone: false,
    showFileNamesInPreview: true
};
DropzoneDialogBase.propTypes = {
    ...DropzoneAreaBase.propTypes,

    /** Sets whether the dialog is open or closed. */
    open: PropTypes.bool,

    /** The Dialog title. */
    dialogTitle: PropTypes.string,

    /**
     * Props to pass to the Material-UI Dialog components.
     * @see See [Material-UI Dialog](https://material-ui.com/api/dialog/#props) for available values.
     */
    dialogProps: PropTypes.object,

    /**
     * If `true`, the dialog stretches to `maxWidth`.<br/>
     * Notice that the dialog width grow is limited by the default margin.
     */
    fullWidth: PropTypes.bool,

    /**
     * Determine the max-width of the dialog. The dialog width grows with the size of the screen.<br/>
     * Set to `false` to disable `maxWidth`.
     */
    maxWidth: PropTypes.string,

    /** Cancel button text in dialog. */
    cancelButtonText: PropTypes.string,

    /** Submit button text in dialog. */
    submitButtonText: PropTypes.string,

    /**
     * Fired when the modal is closed.
     *
     * @param {SyntheticEvent} event The react `SyntheticEvent`
     */
    onClose: PropTypes.func,

    /**
     * Fired when the user clicks the Submit button.
     *
     * @param {SyntheticEvent} event The react `SyntheticEvent`
     */
    onSave: PropTypes.func,

    /**
     * Shows previews **BELOW** the dropzone.<br/>
     * **Note:** By default previews show up under in the Dialog and inside in the standalone.
     */
    showPreviews: PropTypes.bool,

    /** Shows preview **INSIDE** the dropzone area. */
    showPreviewsInDropzone: PropTypes.bool,

    /** Shows file name under the image. */
    showFileNamesInPreview: PropTypes.bool
};
/**
 * This component provides an uncontrolled version of the DropzoneDialogBase component.
 *
 * It supports all the Props and Methods from `DropzoneDialogBase` but keeps the files state internally.
 *
 * **Note** The `onSave` handler also returns `File[]` with all the accepted files.
 */

const DropzoneDialog = ({
    clearOnUnmount,
    onClose,
    onSave,
    initialFiles,
    filesLimit,
    onDelete,
    onChange,
    ...other
}) => {
    const {
        handleDeleteFile,
        handleAddFiles,
        fileObjects,
        handleResetFiles
    } = useFiles({
        onChange,
        clearOnUnmount,
        initialFiles,
        filesLimit,
        onDelete
    });

    const handleClose = evt => {
        if (onClose) {
            onClose(evt);
        }
    };

    const handleSave = evt => {
        if (onSave) {
            onSave(
                fileObjects.map(fileObject => fileObject.file),
                evt
            );
        }

        if (clearOnUnmount) {
            handleResetFiles();
        }
    };

    return /*#__PURE__*/ createElement(DropzoneDialogBase, {
        clearOnUnmount: clearOnUnmount,
        initialFiles: initialFiles,
        filesLimit: filesLimit,
        onChange: onChange,
        fileObjects: fileObjects,
        onAdd: handleAddFiles,
        onDelete: handleDeleteFile,
        onClose: handleClose,
        onSave: handleSave,
        ...other
    });
};

DropzoneDialog.defaultProps = {
    clearOnUnmount: true,
    filesLimit: 3,
    initialFiles: []
};
DropzoneDialog.propTypes = {
    ...DropzoneDialogBase.propTypes,

    /** Clear uploaded files when component is unmounted. */
    clearOnUnmount: PropTypes.bool,

    /** Maximum number of files that can be loaded into the dropzone. */
    filesLimit: PropTypes.number,

    /** List containing File objects or URL strings.<br/>
     * **Note:** Please take care of CORS.
     */
    initialFiles: PropTypes.arrayOf(
        PropTypes.oneOfType([PropTypes.string, PropTypes.any])
    ),

    /**
     * Fired when the user clicks the Submit button.
     *
     * @param {File[]} files All the files currently inside the Dropzone.
     * @param {SyntheticEvent} event The react `SyntheticEvent`.
     */
    onSave: PropTypes.func
};
export { DropzoneArea, DropzoneAreaBase, DropzoneDialog, DropzoneDialogBase };
